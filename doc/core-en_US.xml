<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE docs SYSTEM "appdocsxml.dtd">
<docs xmlns:xi="http://www.w3.org/2001/XInclude">
	<application name="AELSub" language="en_US">
		<synopsis>
			Launch subroutine built with AEL
		</synopsis>
		<syntax>
			<parameter name="routine" required="true">
				<para>Named subroutine to execute.</para>
			</parameter>
			<parameter name="args" required="false" />
		</syntax>
		<description>
			<para>Execute the named subroutine, defined in AEL, from another dialplan
			language, such as extensions.conf, Realtime extensions, or Lua.</para>
			<para>The purpose of this application is to provide a sane entry point into
			AEL subroutines, the implementation of which may change from time to time.</para>
		</description>
	</application>
	<function name="DUNDILOOKUP" language="en_US">
		<synopsis>
			Do a DUNDi lookup of a phone number.
		</synopsis>
		<syntax>
			<parameter name="number" required="true"/>
			<parameter name="context">
				<para>If not specified the default will be <literal>e164</literal>.</para>
			</parameter>
			<parameter name="options">
				<optionlist>
					<option name="b">
						<para>Bypass the internal DUNDi cache</para>
					</option>
				</optionlist>
			</parameter>
		</syntax>
		<description>
			<para>This will do a DUNDi lookup of the given phone number.</para>
			<para>This function will return the Technology/Resource found in the first result
			in the DUNDi lookup. If no results were found, the result will be blank.</para>
		</description>
	</function>
			
		
	<function name="DUNDIQUERY" language="en_US">
		<synopsis>
			Initiate a DUNDi query.
		</synopsis>
		<syntax>
			<parameter name="number" required="true"/>
			<parameter name="context">
				<para>If not specified the default will be <literal>e164</literal>.</para>
			</parameter>
			<parameter name="options">
				<optionlist>
					<option name="b">
						<para>Bypass the internal DUNDi cache</para>
					</option>
				</optionlist>
			</parameter>
		</syntax>
		<description>
			<para>This will do a DUNDi lookup of the given phone number.</para>
			<para>The result of this function will be a numeric ID that can be used to retrieve
			the results with the <literal>DUNDIRESULT</literal> function.</para>
		</description>
	</function>

	<function name="DUNDIRESULT" language="en_US">
		<synopsis>
			Retrieve results from a DUNDIQUERY.
		</synopsis>
		<syntax>
			<parameter name="id" required="true">
				<para>The identifier returned by the <literal>DUNDIQUERY</literal> function.</para>
			</parameter>
			<parameter name="resultnum">
				<optionlist>
					<option name="number">
						<para>The number of the result that you want to retrieve, this starts at <literal>1</literal></para>
					</option>
					<option name="getnum">
						<para>The total number of results that are available.</para>
					</option>
				</optionlist>
			</parameter>
		</syntax>
		<description>
			<para>This function will retrieve results from a previous use\n"
			of the <literal>DUNDIQUERY</literal> function.</para>
		</description>
	</function>
	<application name="ChanIsAvail" language="en_US">
		<synopsis>
			Check channel availability
		</synopsis>
		<syntax>
			<parameter name="Technology/Resource" required="true" argsep="&amp;">
				<argument name="Technology2/Resource2" multiple="true">
					<para>Optional extra devices to check</para>
					<para>If you need more then one enter them as
					Technology2/Resource2&amp;Technology3/Resourse3&amp;.....</para>
				</argument>
				<para>Specification of the device(s) to check.  These must be in the format of 
				<literal>Technology/Resource</literal>, where <replaceable>Technology</replaceable>
				represents a particular channel driver, and <replaceable>Resource</replaceable>
				represents a resource available to that particular channel driver.</para>
			</parameter>
			<parameter name="options" required="false">
				<optionlist>
					<option name="a">
						<para>Check for all available channels, not only the first one</para>
					</option>
					<option name="s">
						<para>Consider the channel unavailable if the channel is in use at all</para>
					</option>
					<option name="t" implies="s">
						<para>Simply checks if specified channels exist in the channel list</para>
					</option>
				</optionlist>
			</parameter>
		</syntax>
		<description>
			<para>This application will check to see if any of the specified channels are available.</para>
			<para>This application sets the following channel variables:</para>
			<variablelist>
				<variable name="AVAILCHAN">
					<para>The name of the available channel, if one exists</para>
				</variable>
				<variable name="AVAILORIGCHAN">
					<para>The canonical channel name that was used to create the channel</para>
				</variable>
				<variable name="AVAILSTATUS">
					<para>The status code for the available channel. This is used for both
					device state and cause code. It is recommended that you use AVAILORIGCHAN
					instead to see if a device is available or not.</para>
				</variable>
			</variablelist>
		</description>
	</application>
	<application name="DBdel" language="en_US">
		<synopsis>
			Delete a key from the iaxproxy database.
		</synopsis>
		<syntax argsep="/">
			<parameter name="family" required="true" />
			<parameter name="key" required="true" />
		</syntax>
		<description>
			<para>This application will delete a <replaceable>key</replaceable> from the Asterisk
			database.</para>
			<note><para>This application has been DEPRECATED in favor of the DB_DELETE function.</para></note>
		</description>
		<see-also>
			<ref type="function">DB_DELETE</ref>
			<ref type="application">DBdeltree</ref>
			<ref type="function">DB</ref>
		</see-also>
	</application>
	<application name="DBdeltree" language="en_US">
		<synopsis>
			Delete a family or keytree from the iaxproxy database.
		</synopsis>
		<syntax argsep="/">
			<parameter name="family" required="true" />
			<parameter name="keytree" />
		</syntax>
		<description>
			<para>This application will delete a <replaceable>family</replaceable> or <replaceable>keytree</replaceable>
			from the Asterisk database.</para>
		</description>
		<see-also>
			<ref type="function">DB_DELETE</ref>
			<ref type="application">DBdel</ref>
			<ref type="function">DB</ref>
		</see-also>
	</application>
	<application name="Dial" language="en_US">
		<synopsis>
			Attempt to connect to another device or endpoint and bridge the call.
		</synopsis>
		<syntax>
			<parameter name="Technology/Resource" required="true" argsep="&amp;">
				<argument name="Technology/Resource" required="true">
					<para>Specification of the device(s) to dial.  These must be in the format of
					<literal>Technology/Resource</literal>, where <replaceable>Technology</replaceable>
					represents a particular channel driver, and <replaceable>Resource</replaceable>
					represents a resource available to that particular channel driver.</para>
				</argument>
				<argument name="Technology2/Resource2" required="false" multiple="true">
					<para>Optional extra devices to dial in parallel</para>
					<para>If you need more then one enter them as
					Technology2/Resource2&amp;Technology3/Resourse3&amp;.....</para>
				</argument>
			</parameter>
			<parameter name="timeout" required="false">
				<para>Specifies the number of seconds we attempt to dial the specified devices</para>
				<para>If not specified, this defaults to 136 years.</para>
			</parameter>
			<parameter name="options" required="false">
			   <optionlist>
				<option name="A">
					<argument name="x" required="true">
						<para>The file to play to the called party</para>
					</argument>
					<para>Play an announcement to the called party, where <replaceable>x</replaceable> is the prompt to be played</para>
				</option>
				<option name="C">
					<para>Reset the call detail record (CDR) for this call.</para>
				</option>
				<option name="c">
					<para>If the Dial() application cancels this call, always set the flag to tell the channel
					driver that the call is answered elsewhere.</para>
				</option>
				<option name="d">
					<para>Allow the calling user to dial a 1 digit extension while waiting for
					a call to be answered. Exit to that extension if it exists in the
					current context, or the context defined in the <variable>EXITCONTEXT</variable> variable,
					if it exists.</para>
				</option>
				<option name="D" argsep=":">
					<argument name="called" />
					<argument name="calling" />
					<para>Send the specified DTMF strings <emphasis>after</emphasis> the called
					party has answered, but before the call gets bridged. The 
					<replaceable>called</replaceable> DTMF string is sent to the called party, and the 
					<replaceable>calling</replaceable> DTMF string is sent to the calling party. Both arguments 
					can be used alone.</para>
				</option>
				<option name="e">
					<para>Execute the <literal>h</literal> extension for peer after the call ends</para>
				</option>
				<option name="f">
					<para>Force the callerid of the <emphasis>calling</emphasis> channel to be set as the
					extension associated with the channel using a dialplan <literal>hint</literal>.
					For example, some PSTNs do not allow CallerID to be set to anything
					other than the number assigned to the caller.</para>
				</option>
				<option name="F" argsep="^">
					<argument name="context" required="false" />
					<argument name="exten" required="false" />
					<argument name="priority" required="true" />
					<para>When the caller hangs up, transfer the called party
					to the specified destination and continue execution at that location.</para>
				</option>
				<option name="g">
					<para>Proceed with dialplan execution at the next priority in the current extension if the
					destination channel hangs up.</para>
				</option>
				<option name="G" argsep="^">
					<argument name="context" required="false" />
					<argument name="exten" required="false" />
					<argument name="priority" required="true" />
					<para>If the call is answered, transfer the calling party to
					the specified <replaceable>priority</replaceable> and the called party to the specified 
					<replaceable>priority</replaceable> plus one.</para>
					<note>
						<para>You cannot use any additional action post answer options in conjunction with this option.</para>
					</note>
				</option>
				<option name="h">
					<para>Allow the called party to hang up by sending the <literal>*</literal> DTMF digit.</para>
				</option>
				<option name="H">
					<para>Allow the calling party to hang up by hitting the <literal>*</literal> DTMF digit.</para>
				</option>
				<option name="i">
					<para>Asterisk will ignore any forwarding requests it may receive on this dial attempt.</para>
				</option>
				<option name="k">
					<para>Allow the called party to enable parking of the call by sending
					the DTMF sequence defined for call parking in <filename>features.conf</filename>.</para>
				</option>
				<option name="K">
					<para>Allow the calling party to enable parking of the call by sending
					the DTMF sequence defined for call parking in <filename>features.conf</filename>.</para>
				</option>
				<option name="L" argsep=":">
					<argument name="x" required="true">
						<para>Maximum call time, in milliseconds</para>
					</argument>
					<argument name="y">
						<para>Warning time, in milliseconds</para>
					</argument>
					<argument name="z">
						<para>Repeat time, in milliseconds</para>
					</argument>
					<para>Limit the call to <replaceable>x</replaceable> milliseconds. Play a warning when <replaceable>y</replaceable> milliseconds are
					left. Repeat the warning every <replaceable>z</replaceable> milliseconds until time expires.</para>
					<para>This option is affected by the following variables:</para>
					<variablelist>
						<variable name="LIMIT_PLAYAUDIO_CALLER">
							<value name="yes" default="true" />
							<value name="no" />
							<para>If set, this variable causes Asterisk to play the prompts to the caller.</para>
						</variable>
						<variable name="LIMIT_PLAYAUDIO_CALLEE">
							<value name="yes" />
							<value name="no" default="true"/>
							<para>If set, this variable causes Asterisk to play the prompts to the callee.</para>
						</variable>
						<variable name="LIMIT_TIMEOUT_FILE">
							<value name="filename"/>
							<para>If specified, <replaceable>filename</replaceable> specifies the sound prompt to play when the timeout is reached.
							If not set, the time remaining will be announced.</para>
						</variable>
						<variable name="LIMIT_CONNECT_FILE">
							<value name="filename"/>
							<para>If specified, <replaceable>filename</replaceable> specifies the sound prompt to play when the call begins.
							If not set, the time remaining will be announced.</para>
						</variable>
						<variable name="LIMIT_WARNING_FILE">
							<value name="filename"/>
							<para>If specified, <replaceable>filename</replaceable> specifies the sound prompt to play as
							a warning when time <replaceable>x</replaceable> is reached. If not set, the time remaining will be announced.</para>
						</variable>
					</variablelist>
				</option>
				<option name="m">
					<argument name="class" required="false"/>
					<para>Provide hold music to the calling party until a requested
					channel answers. A specific music on hold <replaceable>class</replaceable>
					(as defined in <filename>musiconhold.conf</filename>) can be specified.</para>
				</option>
				<option name="M" argsep="^">
					<argument name="macro" required="true">
						<para>Name of the macro that should be executed.</para>
					</argument>
					<argument name="arg" multiple="true">
						<para>Macro arguments</para>
					</argument>
					<para>Execute the specified <replaceable>macro</replaceable> for the <emphasis>called</emphasis> channel 
					before connecting to the calling channel. Arguments can be specified to the Macro
					using <literal>^</literal> as a delimiter. The macro can set the variable
					<variable>MACRO_RESULT</variable> to specify the following actions after the macro is
					finished executing:</para>
					<variablelist>
						<variable name="MACRO_RESULT">
							<para>If set, this action will be taken after the macro finished executing.</para>
							<value name="ABORT">
								Hangup both legs of the call
							</value>
							<value name="CONGESTION">
								Behave as if line congestion was encountered
							</value>
							<value name="BUSY">
								Behave as if a busy signal was encountered
							</value>
							<value name="CONTINUE">
								Hangup the called party and allow the calling party to continue dialplan execution at the next priority
							</value>
							<!-- TODO: Fix this syntax up, once we've figured out how to specify the GOTO syntax -->
							<value name="GOTO:&lt;context&gt;^&lt;exten&gt;^&lt;priority&gt;">
								Transfer the call to the specified destination.
							</value>
						</variable>
					</variablelist>
					<note>
						<para>You cannot use any additional action post answer options in conjunction
						with this option. Also, pbx services are not run on the peer (called) channel,
						so you will not be able to set timeouts via the TIMEOUT() function in this macro.</para>
					</note>
					<warning><para>Be aware of the limitations that macros have, specifically with regards to use of
					the <literal>WaitExten</literal> application. For more information, see the documentation for
					Macro()</para></warning>
				</option>
				<option name="n">
				        <argument name="delete">
					        <para>With <replaceable>delete</replaceable> either not specified or set to <literal>0</literal>,
						the recorded introduction will not be deleted if the caller hangs up while the remote party has not
						yet answered.</para>
						<para>With <replaceable>delete</replaceable> set to <literal>1</literal>, the introduction will
						always be deleted.</para>
					</argument>
					<para>This option is a modifier for the call screening/privacy mode. (See the 
					<literal>p</literal> and <literal>P</literal> options.) It specifies
					that no introductions are to be saved in the <directory>priv-callerintros</directory>
					directory.</para>
				</option>
				<option name="N">
					<para>This option is a modifier for the call screening/privacy mode. It specifies
					that if Caller*ID is present, do not screen the call.</para>
				</option>
				<option name="o">
					<para>Specify that the Caller*ID that was present on the <emphasis>calling</emphasis> channel
					be set as the Caller*ID on the <emphasis>called</emphasis> channel. This was the
					behavior of Asterisk 1.0 and earlier.</para>
				</option>
				<option name="O">
					<argument name="mode">
						<para>With <replaceable>mode</replaceable> either not specified or set to <literal>1</literal>,
						the originator hanging up will cause the phone to ring back immediately.</para>
						<para>With <replaceable>mode</replaceable> set to <literal>2</literal>, when the operator 
						flashes the trunk, it will ring their phone back.</para>
					</argument>
					<para>Enables <emphasis>operator services</emphasis> mode.  This option only
					works when bridging a DAHDI channel to another DAHDI channel
					only. if specified on non-DAHDI interfaces, it will be ignored.
					When the destination answers (presumably an operator services
					station), the originator no longer has control of their line.
					They may hang up, but the switch will not release their line
					until the destination party (the operator) hangs up.</para>
				</option>
				<option name="p">
					<para>This option enables screening mode. This is basically Privacy mode
					without memory.</para>
				</option>
				<option name="P">
					<argument name="x" />
					<para>Enable privacy mode. Use <replaceable>x</replaceable> as the family/key in the AstDB database if
					it is provided. The current extension is used if a database family/key is not specified.</para>
				</option>
				<option name="r">
					<para>Indicate ringing to the calling party, even if the called party isn't actually ringing. Pass no audio to the calling
					party until the called channel has answered.</para>
				</option>
				<option name="S">
					<argument name="x" required="true" />
					<para>Hang up the call <replaceable>x</replaceable> seconds <emphasis>after</emphasis> the called party has
					answered the call.</para>
				</option>
				<option name="t">
					<para>Allow the called party to transfer the calling party by sending the
					DTMF sequence defined in <filename>features.conf</filename>. This setting does not perform policy enforcement on
					transfers initiated by other methods.</para>
				</option>
				<option name="T">
					<para>Allow the calling party to transfer the called party by sending the
					DTMF sequence defined in <filename>features.conf</filename>. This setting does not perform policy enforcement on
					transfers initiated by other methods.</para>
				</option>
				<option name="U" argsep="^">
					<argument name="x" required="true">
						<para>Name of the subroutine to execute via Gosub</para>
					</argument>
					<argument name="arg" multiple="true" required="false">
						<para>Arguments for the Gosub routine</para>
					</argument>
					<para>Execute via Gosub the routine <replaceable>x</replaceable> for the <emphasis>called</emphasis> channel before connecting
					to the calling channel. Arguments can be specified to the Gosub
					using <literal>^</literal> as a delimiter. The Gosub routine can set the variable
					<variable>GOSUB_RESULT</variable> to specify the following actions after the Gosub returns.</para>
					<variablelist>
						<variable name="GOSUB_RESULT">
							<value name="ABORT">
								Hangup both legs of the call.
							</value>
							<value name="CONGESTION">
								Behave as if line congestion was encountered.
							</value>
							<value name="BUSY">
								Behave as if a busy signal was encountered.
							</value>
							<value name="CONTINUE">
								Hangup the called party and allow the calling party
								to continue dialplan execution at the next priority.
							</value>
							<!-- TODO: Fix this syntax up, once we've figured out how to specify the GOTO syntax -->
							<value name="GOTO:&lt;context&gt;^&lt;exten&gt;^&lt;priority&gt;">
								Transfer the call to the specified priority. Optionally, an extension, or
								extension and priority can be specified.
							</value>
						</variable>
					</variablelist>
					<note>
						<para>You cannot use any additional action post answer options in conjunction
						with this option. Also, pbx services are not run on the peer (called) channel,
						so you will not be able to set timeouts via the TIMEOUT() function in this routine.</para>
					</note>
				</option>
				<option name="w">
					<para>Allow the called party to enable recording of the call by sending
					the DTMF sequence defined for one-touch recording in <filename>features.conf</filename>.</para>
				</option>
				<option name="W">
					<para>Allow the calling party to enable recording of the call by sending
					the DTMF sequence defined for one-touch recording in <filename>features.conf</filename>.</para>
				</option>
				<option name="x">
					<para>Allow the called party to enable recording of the call by sending
					the DTMF sequence defined for one-touch automixmonitor in <filename>features.conf</filename>.</para>
				</option>
				<option name="X">
					<para>Allow the calling party to enable recording of the call by sending
					the DTMF sequence defined for one-touch automixmonitor in <filename>features.conf</filename>.</para>
				</option>
				</optionlist>
			</parameter>
			<parameter name="URL">
				<para>The optional URL will be sent to the called party if the channel driver supports it.</para>
			</parameter>
		</syntax>
		<description>
			<para>This application will place calls to one or more specified channels. As soon
			as one of the requested channels answers, the originating channel will be
			answered, if it has not already been answered. These two channels will then
			be active in a bridged call. All other channels that were requested will then
			be hung up.</para>

			<para>Unless there is a timeout specified, the Dial application will wait
			indefinitely until one of the called channels answers, the user hangs up, or
			if all of the called channels are busy or unavailable. Dialplan executing will
			continue if no requested channels can be called, or if the timeout expires.
			This application will report normal termination if the originating channel
			hangs up, or if the call is bridged and either of the parties in the bridge
			ends the call.</para>

			<para>If the <variable>OUTBOUND_GROUP</variable> variable is set, all peer channels created by this
			application will be put into that group (as in Set(GROUP()=...).
			If the <variable>OUTBOUND_GROUP_ONCE</variable> variable is set, all peer channels created by this
			application will be put into that group (as in Set(GROUP()=...). Unlike OUTBOUND_GROUP,
			however, the variable will be unset after use.</para>

			<para>This application sets the following channel variables:</para>
			<variablelist>
				<variable name="DIALEDTIME">
					<para>This is the time from dialing a channel until when it is disconnected.</para>
				</variable>
				<variable name="ANSWEREDTIME">
					<para>This is the amount of time for actual call.</para>
				</variable>
				<variable name="DIALSTATUS">
					<para>This is the status of the call</para>
					<value name="CHANUNAVAIL" />
					<value name="CONGESTION" />
					<value name="NOANSWER" />
					<value name="BUSY" />
					<value name="ANSWER" />
					<value name="CANCEL" />
					<value name="DONTCALL">
						For the Privacy and Screening Modes.
						Will be set if the called party chooses to send the calling party to the 'Go Away' script.
					</value>
					<value name="TORTURE">
						For the Privacy and Screening Modes.
						Will be set if the called party chooses to send the calling party to the 'torture' script.
					</value>
					<value name="INVALIDARGS" />
				</variable>
			</variablelist>
		</description>
	</application>
	<application name="RetryDial" language="en_US">
		<synopsis>
			Place a call, retrying on failure allowing an optional exit extension.
		</synopsis>
		<syntax>
			<parameter name="announce" required="true">
				<para>Filename of sound that will be played when no channel can be reached</para>
			</parameter>
			<parameter name="sleep" required="true">
				<para>Number of seconds to wait after a dial attempt failed before a new attempt is made</para>
			</parameter>
			<parameter name="retries" required="true">
				<para>Number of retries</para>
				<para>When this is reached flow will continue at the next priority in the dialplan</para>
			</parameter>
			<parameter name="dialargs" required="true">
				<para>Same format as arguments provided to the Dial application</para>
			</parameter>
		</syntax>
		<description>
			<para>This application will attempt to place a call using the normal Dial application.
			If no channel can be reached, the <replaceable>announce</replaceable> file will be played.
			Then, it will wait <replaceable>sleep</replaceable> number of seconds before retrying the call.
			After <replaceable>retries</replaceable> number of attempts, the calling channel will continue at the next priority in the dialplan.
			If the <replaceable>retries</replaceable> setting is set to 0, this application will retry endlessly.
			While waiting to retry a call, a 1 digit extension may be dialed. If that
			extension exists in either the context defined in <variable>EXITCONTEXT</variable> or the current
			one, The call will jump to that extension immediately.
			The <replaceable>dialargs</replaceable> are specified in the same format that arguments are provided
			to the Dial application.</para>
		</description>
	</application>
	<application name="Playback" language="en_US">
		<synopsis>
			Play a file.
		</synopsis>
		<syntax>
			<parameter name="filenames" required="true" argsep="&amp;">
				<argument name="filename" required="true" />
				<argument name="filename2" multiple="true" />
			</parameter>
			<parameter name="options">
				<para>Comma separated list of options</para>
				<optionlist>
					<option name="skip">
						<para>Do not play if not answered</para>
					</option>
					<option name="noanswer">
						<para>Playback without answering, otherwise the channel will
						be answered before the sound is played.</para>
						<note><para>Not all channel types support playing messages while still on hook.</para></note>
					</option>
				</optionlist>
			</parameter>
		</syntax>
		<description>
			<para>Plays back given filenames (do not put extension of wav/alaw etc).
			The playback command answer the channel if no options are specified.
			If the file is non-existant it will fail</para>
			<para>This application sets the following channel variable upon completion:</para>
			<variablelist>
				<variable name="PLAYBACKSTATUS">
					<para>The status of the playback attempt as a text string.</para>
					<value name="SUCCESS"/>
					<value name="FAILED"/>
				</variable>
			</variablelist>
			<para>See Also: Background (application) -- for playing sound files that are interruptible</para>
			<para>WaitExten (application) -- wait for digits from caller, optionally play music on hold</para>
		</description>
	</application>
	<application name="SetCallerPres" language="en_US">
		<synopsis>
			Set CallerID Presentation.
		</synopsis>
		<syntax>
			<parameter name="presentation" required="true">
				<enumlist>
					<enum name="allowed_not_screened">
						<para>Presentation Allowed, Not Screened.</para>
					</enum>
					<enum name="allowed_passed_screen">
						<para>Presentation Allowed, Passed Screen.</para>
					</enum>
					<enum name="allowed_failed_screen">
						<para>Presentation Allowed, Failed Screen.</para>
					</enum>
					<enum name="allowed">
						<para>Presentation Allowed, Network Number.</para>
					</enum>
					<enum name="prohib_not_screened">
						<para>Presentation Prohibited, Not Screened.</para>
					</enum>
					<enum name="prohib_passed_screen">
						<para>Presentation Prohibited, Passed Screen.</para>
					</enum>
					<enum name="prohib_failed_screen">
						<para>Presentation Prohibited, Failed Screen.</para>
					</enum>
					<enum name="prohib">
						<para>Presentation Prohibited, Network Number.</para>
					</enum>
					<enum name="unavailable">
						<para>Number Unavailable.</para>
					</enum>
				</enumlist>
			</parameter>
		</syntax>
		<description>
			<para>Set Caller*ID presentation on a call.</para>
		</description>
	</application>
	<application name="Verbose" language="en_US">
 		<synopsis>
			Send arbitrary text to verbose output.
		</synopsis>
		<syntax>
			<parameter name="level">
				<para>Must be an integer value.  If not specified, defaults to 0.</para>
			</parameter>
			<parameter name="message" required="true">
				<para>Output text message.</para>
			</parameter>
		</syntax>
		<description>
			<para>Sends an arbitrary text message to verbose output.</para>
		</description>
	</application>
	<application name="Log" language="en_US">
		<synopsis>
			Send arbitrary text to a selected log level.
		</synopsis>
		<syntax>
			<parameter name="level" required="true">
				<para>Level must be one of <literal>ERROR</literal>, <literal>WARNING</literal>, <literal>NOTICE</literal>,
				<literal>DEBUG</literal>, <literal>VERBOSE</literal> or <literal>DTMF</literal>.</para>	
			</parameter>
			<parameter name="message" required="true">
				<para>Output text message.</para>
			</parameter>
		</syntax>
		<description>
			<para>Sends an arbitrary text message to a selected log level.</para>
		</description>
	</application>
	<function name="AES_ENCRYPT" language="en_US">
		<synopsis>
			Encrypt a string with AES given a 16 character key.
		</synopsis>
		<syntax>
			<parameter name="key" required="true">
				<para>AES Key</para>
			</parameter>
			<parameter name="string" required="true">
				<para>Input string</para>
			</parameter>
		</syntax>
		<description>
			<para>Returns an AES encrypted string encoded in base64.</para>
		</description>
		<see-also>
			<ref type="function">AES_DECRYPT</ref>
			<ref type="function">BASE64_ENCODE</ref>
			<ref type="function">BASE64_DECODE</ref>
		</see-also>
	</function>
	<function name="AES_DECRYPT" language="en_US">
		<synopsis>
			Decrypt a string encoded in base64 with AES given a 16 character key.
		</synopsis>
		<syntax>
			<parameter name="key" required="true">
				<para>AES Key</para>
			</parameter>
			<parameter name="string" required="true">
				<para>Input string.</para>
			</parameter>
		</syntax>
		<description>
			<para>Returns the plain text string.</para>
		</description>
		<see-also>
			<ref type="function">AES_ENCRYPT</ref>
			<ref type="function">BASE64_ENCODE</ref>
			<ref type="function">BASE64_DECODE</ref>
		</see-also>
	</function>
 	<function name = "AUDIOHOOK_INHERIT" language="en_US">
		<synopsis>
			Set whether an audiohook may be inherited to another channel
		</synopsis>
		<syntax>
			<parameter name="source" required="true">
				<para>The built-in sources in Asterisk are</para>
				<enumlist>
					<enum name="MixMonitor" />
					<enum name="Chanspy" />
					<enum name="Volume" />
					<enum name="Speex" />
					<enum name="JACK_HOOK" />
				</enumlist>
				<para>Note that the names are not case-sensitive</para>
			</parameter>
		</syntax>
		<description>
			<para>By enabling audiohook inheritance on the channel, you are giving
			permission for an audiohook to be inherited by a descendent channel.
			Inheritance may be be disabled at any point as well.</para>

			<para>Example scenario:</para>
			<para>exten => 2000,1,MixMonitor(blah.wav)</para>
			<para>exten => 2000,n,Set(AUDIOHOOK_INHERIT(MixMonitor)=yes)</para>
			<para>exten => 2000,n,Dial(SIP/2000)</para>
			<para>
			</para>
			<para>exten => 4000,1,Dial(SIP/4000)</para>
			<para>
			</para>
			<para>exten => 5000,1,MixMonitor(blah2.wav)</para>
			<para>exten => 5000,n,Dial(SIP/5000)</para>
			<para>
			</para>
			<para>In this basic dialplan scenario, let's consider the following sample calls</para>
			<para>Call 1: Caller dials 2000. The person who answers then executes an attended</para>
			<para>        transfer to 4000.</para>
			<para>Result: Since extension 2000 set MixMonitor to be inheritable, after the</para>
			<para>        transfer to 4000 has completed, the call will continue to be recorded
			to blah.wav</para>
			<para>
			</para>
			<para>Call 2: Caller dials 5000. The person who answers then executes an attended</para>
			<para>        transfer to 4000.</para>
			<para>Result: Since extension 5000 did not set MixMonitor to be inheritable, the</para>
			<para>        recording will stop once the call has been transferred to 4000.</para>
		</description>
	</function>
	<function name="BASE64_ENCODE" language="en_US">
		<synopsis>
			Encode a string in base64.
		</synopsis>
		<syntax>
			<parameter name="string" required="true">
				<para>Input string</para>
			</parameter>
		</syntax>
		<description>
			<para>Returns the base64 string.</para>
		</description>
		<see-also>
			<ref type="function">BASE64_DECODE</ref>
			<ref type="function">AES_DECRYPT</ref>
			<ref type="function">AES_ENCRYPT</ref>
		</see-also>
	</function>
	<function name="BASE64_DECODE" language="en_US">
		<synopsis>
			Decode a base64 string.
		</synopsis>
		<syntax>
			<parameter name="string" required="true">
				<para>Input string.</para>
			</parameter>
		</syntax>
		<description>
			<para>Returns the plain text string.</para>
		</description>
		<see-also>
			<ref type="function">BASE64_ENCODE</ref>
			<ref type="function">AES_DECRYPT</ref>
			<ref type="function">AES_ENCRYPT</ref>
		</see-also>
	</function>
	<function name="BLACKLIST" language="en_US">
		<synopsis>
			Check if the callerid is on the blacklist.
		</synopsis>
		<syntax />
		<description>
			<para>Uses astdb to check if the Caller*ID is in family <literal>blacklist</literal>.
			Returns <literal>1</literal> or <literal>0</literal>.</para>
		</description>
		<see-also>
			<ref type="function">DB</ref>
		</see-also>
	</function>

	<function name="CALLERID" language="en_US">
		<synopsis>
			Gets or sets Caller*ID data on the channel.
		</synopsis>
		<syntax>
			<parameter name="datatype" required="true">
				<para>The allowable datatypes are:</para>
				<enumlist>
					<enum name="all" />
					<enum name="num" />
					<enum name="name" />
					<enum name="ANI" />
					<enum name="DNID" />
					<enum name="RDNIS" />
					<enum name="pres" />
					<enum name="ton" />
				</enumlist>
			</parameter>
			<parameter name="CID">
				<para>Optional Caller*ID</para>
			</parameter>
		</syntax>
		<description>
			<para>Gets or sets Caller*ID data on the channel. Uses channel callerid by default or optional
			callerid, if specified.</para>
		</description>
	</function>
	<function name="CALLERPRES" language="en_US">
		<synopsis>
			Gets or sets Caller*ID presentation on the channel.
		</synopsis>
		<syntax />
		<description>
			<para>Gets or sets Caller*ID presentation on the channel. The following values
			are valid:</para>
			<enumlist>
				<enum name="allowed_not_screened">
					<para>Presentation Allowed, Not Screened.</para>
				</enum>
				<enum name="allowed_passed_screen">
					<para>Presentation Allowed, Passed Screen.</para>
				</enum>
				<enum name="allowed_failed_screen">
					<para>Presentation Allowed, Failed Screen.</para>
				</enum>
				<enum name="allowed">
					<para>Presentation Allowed, Network Number.</para>
				</enum>
				<enum name="prohib_not_screened">
					<para>Presentation Prohibited, Not Screened.</para>
				</enum>
				<enum name="prohib_passed_screen">
					<para>Presentation Prohibited, Passed Screen.</para>
				</enum>
				<enum name="prohib_failed_screen">
					<para>Presentation Prohibited, Failed Screen.</para>
				</enum>
				<enum name="prohib">
					<para>Presentation Prohibited, Network Number.</para>
				</enum>
				<enum name="unavailable">
					<para>Number Unavailable.</para>
				</enum>
			</enumlist>
		</description>
	</function>
	<function name="CDR" language="en_US">
		<synopsis>
			Gets or sets a CDR variable.
		</synopsis>	
		<syntax>
			<parameter name="name" required="true">
				<para>CDR field name:</para>
				<enumlist>
					<enum name="clid">
						<para>Caller ID.</para>
					</enum>
					<enum name="lastdata">
						<para>Last application arguments.</para>
					</enum>
					<enum name="disposition">
						<para>ANSWERED, NO ANSWER, BUSY, FAILED.</para>
					</enum>
					<enum name="src">
						<para>Source.</para>
					</enum>
					<enum name="start">
						<para>Time the call started.</para>
					</enum>
					<enum name="amaflags">
						<para>DOCUMENTATION, BILL, IGNORE, etc.</para>
					</enum>
					<enum name="dst">
						<para>Destination.</para>
					</enum>
					<enum name="answer">
						<para>Time the call was answered.</para>
					</enum>
					<enum name="accountcode">
						<para>The channel's account code.</para>
					</enum>
					<enum name="dcontext">
						<para>Destination context.</para>
					</enum>
					<enum name="end">
						<para>Time the call ended.</para>
					</enum>
					<enum name="uniqueid">
						<para>The channel's unique id.</para>
					</enum>
					<enum name="dstchannel">
						<para>Destination channel.</para>
					</enum>
					<enum name="duration">
						<para>Duration of the call.</para>
					</enum>
					<enum name="userfield">
						<para>The channel's user specified field.</para>
					</enum>
					<enum name="lastapp">
						<para>Last application.</para>
					</enum>
					<enum name="billsec">
						<para>Duration of the call once it was answered.</para>
					</enum>
					<enum name="channel">
						<para>Channel name.</para>
					</enum>
				</enumlist>
			</parameter>
			<parameter name="options" required="false">
				<optionlist>
					<option name="l">
						<para>Uses the most recent CDR on a channel with multiple records</para>
					</option>
					<option name="r">
						<para>Searches the entire stack of CDRs on the channel.</para>
					</option>
					<option name="s">
						<para>Skips any CDR's that are marked 'LOCKED' due to forkCDR() calls.
						(on setting/writing CDR vars only)</para>
					</option>
					<option name="u">
						<para>Retrieves the raw, unprocessed value.</para>
						<para>For example, 'start', 'answer', and 'end' will be retrieved as epoch
						values, when the <literal>u</literal> option is passed, but formatted as YYYY-MM-DD HH:MM:SS
						otherwise.  Similarly, disposition and amaflags will return their raw
						integral values.</para>
					</option>
				</optionlist>
			</parameter>
		</syntax>
		<description>
			<para>All of the CDR field names are read-only, except for <literal>accountcode</literal>,
			<literal>userfield</literal>, and <literal>amaflags</literal>. You may, however, supply
			a name not on the above list, and create your own variable, whose value can be changed
			with this function, and this variable will be stored on the cdr.</para>
			<note><para>For setting CDR values, the <literal>l</literal> flag does not apply to
			setting the <literal>accountcode</literal>, <literal>userfield</literal>, or
			<literal>amaflags</literal>.</para></note>
			<para>Raw values for <literal>disposition</literal>:</para>
			<enumlist>
				<enum name="0">
					<para>NO ANSWER</para>
				</enum>
				<enum name="1">
					<para>NO ANSWER (NULL record)</para>
				</enum>
				<enum name="2">
					<para>FAILED</para>
				</enum>
				<enum name="4">
					<para>BUSY</para>
				</enum>
				<enum name="8">
					<para>ANSWERED</para>
				</enum>
			</enumlist>
			<para>Raw values for <literal>amaflags</literal>:</para>
			<enumlist>
				<enum name="1">
					<para>OMIT</para>
				</enum>
				<enum name="2">
					<para>BILLING</para>
				</enum>
				<enum name="3">
					<para>DOCUMENTATION</para>
				</enum>
			</enumlist>
			<para>Example: exten => 1,1,Set(CDR(userfield)=test)</para>
		</description>
	</function>
	<function name="CHANNELS" language="en_US">
		<synopsis>
			Gets the list of channels, optionally filtering by a regular expression.
		</synopsis>
		<syntax>
			<parameter name="regular_expression" />
		</syntax>
		<description>
			<para>Gets the list of channels, optionally filtering by a <replaceable>regular_expression</replaceable>. If
			no argument is provided, all known channels are returned. The
			<replaceable>regular_expression</replaceable> must correspond to
			the POSIX.2 specification, as shown in <emphasis>regex(7)</emphasis>. The list returned
			will be space-delimited.</para>
		</description>
	</function>
	<function name="CHANNEL" language="en_US">
		<synopsis>
			Gets/sets various pieces of information about the channel.
		</synopsis>
		<syntax>
			<parameter name="item" required="true">
				<para>Standard items (provided by all channel technologies) are:</para>
				<enumlist>
					<enum name="audioreadformat">
						<para>R/O format currently being read.</para>
					</enum>
					<enum name="audionativeformat">
						<para>R/O format used natively for audio.</para>
					</enum>
					<enum name="audiowriteformat">
						<para>R/O format currently being written.</para>
					</enum>
					<enum name="callgroup">
						<para>R/W call groups for call pickup.</para>
					</enum>
					<enum name="channeltype">
						<para>R/O technology used for channel.</para>
					</enum>
					<enum name="language">
						<para>R/W language for sounds played.</para>
					</enum>
					<enum name="musicclass">
						<para>R/W class (from musiconhold.conf) for hold music.</para>
					</enum>
					<enum name="parkinglot">
						<para>R/W parkinglot for parking.</para>
					</enum>
					<enum name="rxgain">
						<para>R/W set rxgain level on channel drivers that support it.</para>
					</enum>
					<enum name="state">
						<para>R/O state for channel</para>
					</enum>
					<enum name="tonezone">
						<para>R/W zone for indications played</para>
					</enum>
					<enum name="transfercapability">
						<para>R/W ISDN Transfer Capability, one of:</para>
						<enumlist>
							<enum name="SPEECH" />
							<enum name="DIGITAL" />
							<enum name="RESTRICTED_DIGITAL" />
							<enum name="3K1AUDIO" />
							<enum name="DIGITAL_W_TONES" />
							<enum name="VIDEO" />
						</enumlist>
					</enum>
					<enum name="txgain">
						<para>R/W set txgain level on channel drivers that support it.</para>
					</enum>
					<enum name="videonativeformat">
						<para>R/O format used natively for video</para>
					</enum>
					<enum name="trace">
						<para>R/W whether or not context tracing is enabled, only available
						<emphasis>if CHANNEL_TRACE is defined</emphasis>.</para>
					</enum>
				</enumlist>
				<para><emphasis>chan_sip</emphasis> provides the following additional options:</para>
				<enumlist>
					<enum name="peerip">
						<para>R/O Get the IP address of the peer.</para>
					</enum>
					<enum name="recvip">
						<para>R/O Get the source IP address of the peer.</para>
					</enum>
					<enum name="from">
						<para>R/O Get the URI from the From: header.</para>
					</enum>
					<enum name="uri">
						<para>R/O Get the URI from the Contact: header.</para>
					</enum>
					<enum name="useragent">
						<para>R/O Get the useragent.</para>
					</enum>
					<enum name="peername">
						<para>R/O Get the name of the peer.</para>
					</enum>
					<enum name="t38passthrough">
						<para>R/O <literal>1</literal> if T38 is offered or enabled in this channel,
						otherwise <literal>0</literal></para>
					</enum>
					<enum name="rtpqos">
						<para>R/O Get QOS information about the RTP stream</para>
						<para>    This option takes two additional arguments:</para>
						<para>    Argument 1:</para>
						<para>     <literal>audio</literal>             Get data about the audio stream</para>
						<para>     <literal>video</literal>             Get data about the video stream</para>
						<para>     <literal>text</literal>              Get data about the text stream</para>
						<para>    Argument 2:</para>
						<para>     <literal>local_ssrc</literal>        Local SSRC (stream ID)</para>
						<para>     <literal>local_lostpackets</literal> Local lost packets</para>
						<para>     <literal>local_jitter</literal>      Local calculated jitter</para>
						<para>     <literal>local_maxjitter</literal>   Local calculated jitter (maximum)</para>
						<para>     <literal>local_minjitter</literal>   Local calculated jitter (minimum)</para>
						<para>     <literal>local_normdevjitter</literal>Local calculated jitter (normal deviation)</para>
						<para>     <literal>local_stdevjitter</literal> Local calculated jitter (standard deviation)</para>
						<para>     <literal>local_count</literal>       Number of received packets</para>
						<para>     <literal>remote_ssrc</literal>       Remote SSRC (stream ID)</para>
						<para>     <literal>remote_lostpackets</literal>Remote lost packets</para>
						<para>     <literal>remote_jitter</literal>     Remote reported jitter</para>
						<para>     <literal>remote_maxjitter</literal>  Remote calculated jitter (maximum)</para>
						<para>     <literal>remote_minjitter</literal>  Remote calculated jitter (minimum)</para>
						<para>     <literal>remote_normdevjitter</literal>Remote calculated jitter (normal deviation)</para>
						<para>     <literal>remote_stdevjitter</literal>Remote calculated jitter (standard deviation)</para>
						<para>     <literal>remote_count</literal>      Number of transmitted packets</para>
						<para>     <literal>rtt</literal>               Round trip time</para>
						<para>     <literal>maxrtt</literal>            Round trip time (maximum)</para>
						<para>     <literal>minrtt</literal>            Round trip time (minimum)</para>
						<para>     <literal>normdevrtt</literal>        Round trip time (normal deviation)</para>
						<para>     <literal>stdevrtt</literal>          Round trip time (standard deviation)</para>
						<para>     <literal>all</literal>               All statistics (in a form suited to logging,
						but not for parsing)</para>
					</enum>
					<enum name="rtpdest">
						<para>R/O Get remote RTP destination information.</para>
						<para>   This option takes one additional argument:</para>
						<para>    Argument 1:</para>
						<para>     <literal>audio</literal>             Get audio destination</para>
						<para>     <literal>video</literal>             Get video destination</para>
						<para>     <literal>text</literal>              Get text destination</para>
					</enum>
				</enumlist>
				<para><emphasis>chan_iax2</emphasis> provides the following additional options:</para>
				<enumlist>
					<enum name="peerip">
						<para>R/O Get the peer's ip address.</para>
					</enum>
					<enum name="peername">
						<para>R/O Get the peer's username.</para>
					</enum>
				</enumlist>
			</parameter>
		</syntax>
		<description>
			<para>Gets/sets various pieces of information about the channel, additional <replaceable>item</replaceable> may
			be available from the channel driver; see its documentation for details. Any <replaceable>item</replaceable>
			requested that is not available on the current channel will return an empty string.</para>
		</description>
	</function>
	<function name="AST_CONFIG" language="en_US">
		<synopsis>
			Retrieve a variable from a configuration file.
		</synopsis>
		<syntax>
			<parameter name="config_file" required="true" />
			<parameter name="category" required="true" />
			<parameter name="variable_name" required="true" />
		</syntax>
		<description>
			<para>This function reads a variable from an Asterisk configuration file.</para>
		</description>
	</function>

	<function name="SORT" language="en_US">
		<synopsis>
			Sorts a list of key/vals into a list of keys, based upon the vals.	
		</synopsis>
		<syntax>
			<parameter name="keyval" required="true" argsep=":">
				<argument name="key1" required="true" />
				<argument name="val1" required="true" />
			</parameter>
			<parameter name="keyvaln" multiple="true" argsep=":">
				<argument name="key2" required="true" />
				<argument name="val2" required="true" />
			</parameter>
		</syntax>
		<description>
			<para>Takes a comma-separated list of keys and values, each separated by a colon, and returns a
			comma-separated list of the keys, sorted by their values.  Values will be evaluated as
			floating-point numbers.</para>
		</description>
	</function>
	<function name="CUT" language="en_US">
		<synopsis>
			Slices and dices strings, based upon a named delimiter.		
		</synopsis>
		<syntax>
			<parameter name="varname" required="true">
				<para>Variable you want cut</para>
			</parameter>
			<parameter name="char-delim" required="true">
				<para>Delimiter, defaults to <literal>-</literal></para>
			</parameter>
			<parameter name="range-spec" required="true">
				<para>Number of the field you want (1-based offset), may also be specified as a range (with <literal>-</literal>)
				or group of ranges and fields (with <literal>&amp;</literal>)</para>
			</parameter>
		</syntax>
		<description>
			<para>Cut out information from a string (<replaceable>varname</replaceable>), based upon a named delimiter.</para>
		</description>	
	</function>
	<function name="DB" language="en_US">
		<synopsis>
			Read from or write to the Asterisk database.
		</synopsis>
		<syntax argsep="/">
			<parameter name="family" required="true" />
			<parameter name="key" required="true" />
		</syntax>
		<description>
			<para>This function will read from or write a value to the Asterisk database.  On a
			read, this function returns the corresponding value from the database, or blank
			if it does not exist.  Reading a database value will also set the variable
			DB_RESULT.  If you wish to find out if an entry exists, use the DB_EXISTS
			function.</para>
		</description>
		<see-also>
			<ref type="application">DBdel</ref>
			<ref type="function">DB_DELETE</ref>
			<ref type="application">DBdeltree</ref>
			<ref type="function">DB_EXISTS</ref>
		</see-also>
	</function>
	<function name="DB_EXISTS" language="en_US">
		<synopsis>
			Check to see if a key exists in the Asterisk database.
		</synopsis>
		<syntax argsep="/">
			<parameter name="family" required="true" />
			<parameter name="key" required="true" />
		</syntax>
		<description>
			<para>This function will check to see if a key exists in the Asterisk
			database. If it exists, the function will return <literal>1</literal>. If not,
			it will return <literal>0</literal>.  Checking for existence of a database key will
			also set the variable DB_RESULT to the key's value if it exists.</para>
		</description>
		<see-also>
			<ref type="function">DB</ref>
		</see-also>
	</function>
	<function name="DB_DELETE" language="en_US">
		<synopsis>
			Return a value from the database and delete it.
		</synopsis>
		<syntax argsep="/">
			<parameter name="family" required="true" />
			<parameter name="key" required="true" />
		</syntax>
		<description>
			<para>This function will retrieve a value from the Asterisk database
			and then remove that key from the database. <variable>DB_RESULT</variable>
			will be set to the key's value if it exists.</para>
		</description>
		<see-also>
			<ref type="application">DBdel</ref>
			<ref type="function">DB</ref>
			<ref type="application">DBdeltree</ref>
		</see-also>
	</function>
	<function name="DEVICE_STATE" language="en_US">
		<synopsis>
			Get or Set a device state.
		</synopsis>
		<syntax>
			<parameter name="device" required="true" />
		</syntax>
		<description>
			<para>The DEVICE_STATE function can be used to retrieve the device state from any
			device state provider. For example:</para>
			<para>NoOp(SIP/mypeer has state ${DEVICE_STATE(SIP/mypeer)})</para>
			<para>NoOp(Conference number 1234 has state ${DEVICE_STATE(MeetMe:1234)})</para>
			<para>The DEVICE_STATE function can also be used to set custom device state from
			the dialplan.  The <literal>Custom:</literal> prefix must be used. For example:</para>
			<para>Set(DEVICE_STATE(Custom:lamp1)=BUSY)</para>
			<para>Set(DEVICE_STATE(Custom:lamp2)=NOT_INUSE)</para>
			<para>You can subscribe to the status of a custom device state using a hint in
			the dialplan:</para>
			<para>exten => 1234,hint,Custom:lamp1</para>
			<para>The possible values for both uses of this function are:</para>
			<para>UNKNOWN | NOT_INUSE | INUSE | BUSY | INVALID | UNAVAILABLE | RINGING |
			RINGINUSE | ONHOLD</para>
		</description>
	</function>
	<function name="HINT" language="en_US">
		<synopsis>
			Get the devices set for a dialplan hint.
		</synopsis>
		<syntax>
			<parameter name="extension" required="true" argsep="@">
				<argument name="extension" required="true" />
				<argument name="context" />
			</parameter>
			<parameter name="options">
				<optionlist>
					<option name="n">
						<para>Retrieve name on the hint instead of list of devices.</para>
					</option>
				</optionlist>
			</parameter>
		</syntax>
		<description>
			<para>The HINT function can be used to retrieve the list of devices that are
			mapped to a dialplan hint. For example:</para>
			<para>NoOp(Hint for Extension 1234 is ${HINT(1234)})</para>
		</description>
	</function>
	<function name="DIALGROUP" language="en_US">
		<synopsis>
			Manages a group of users for dialing.
		</synopsis>
		<syntax>
			<parameter name="group" required="true" />
			<parameter name="op">
				<para>The operation name, possible values are:</para>
				<para><literal>add</literal> - add a channel name or interface (write-only)</para>
				<para><literal>del</literal> - remove a channel name or interface (write-only)</para>
			</parameter>
		</syntax>
		<description>
			<para>Presents an interface meant to be used in concert with the Dial
			application, by presenting a list of channels which should be dialled when
			referenced.</para>
			<para>When DIALGROUP is read from, the argument is interpreted as the particular
			<replaceable>group</replaceable> for which a dial should be attempted.  When DIALGROUP is written to
			with no arguments, the entire list is replaced with the argument specified.</para>
			<para>Functionality is similar to a queue, except that when no interfaces are
			available, execution may continue in the dialplan.  This is useful when
			you want certain people to be the first to answer any calls, with immediate
			fallback to a queue when the front line people are busy or unavailable, but
			you still want front line people to log in and out of that group, just like
			a queue.</para>
			<para>Example:</para>
			<para>exten => 1,1,Set(DIALGROUP(mygroup,add)=SIP/10)</para>
			<para>exten => 1,n,Set(DIALGROUP(mygroup,add)=SIP/20)</para>
			<para>exten => 1,n,Dial(${DIALGROUP(mygroup)})</para>
		</description>
	</function>
	<function name="DIALPLAN_EXISTS" language="en_US">
		<synopsis>
			Checks the existence of a dialplan target.
		</synopsis>
		<syntax>
			<parameter name="context" required="true" />
			<parameter name="extension" />
			<parameter name="priority" />
		</syntax>
		<description>
			<para>This function returns <literal>1</literal> if the target exits. Otherwise, it returns <literal>0</literal>.</para>
		</description>
	</function>

	<function name="ENUMQUERY" language="en_US">
		<synopsis>
			Initiate an ENUM query.
		</synopsis>
		<syntax>
			<parameter name="number" required="true" />
			<parameter name="method-type">
				<para>If no <replaceable>method-type</replaceable> is given, the default will be
				<literal>sip</literal>.</para>
			</parameter>
			<parameter name="zone-suffix">
				<para>If no <replaceable>zone-suffix</replaceable> is given, the default will be
				<literal>e164.arpa</literal></para>
			</parameter>
		</syntax>
		<description>
			<para>This will do a ENUM lookup of the given phone number.</para>
		</description>
	</function>
	<function name="ENUMRESULT" language="en_US">
		<synopsis>
			Retrieve results from a ENUMQUERY.
		</synopsis>
		<syntax>
			<parameter name="id" required="true">
				<para>The identifier returned by the ENUMQUERY function.</para>
			</parameter>
			<parameter name="resultnum" required="true">
				<para>The number of the result that you want to retrieve.</para>
				<para>Results start at <literal>1</literal>. If this argument is specified
				as <literal>getnum</literal>, then it will return the total number of results 
				that are available.</para>
			</parameter>
		</syntax>
		<description>
			<para>This function will retrieve results from a previous use
			of the ENUMQUERY function.</para>
		</description>
	</function>	
	<function name="ENUMLOOKUP" language="en_US">
		<synopsis>
			General or specific querying of NAPTR records for ENUM or ENUM-like DNS pointers.
		</synopsis>
		<syntax>
			<parameter name="number" required="true" />
			<parameter name="method-type">
				<para>If no <replaceable>method-type</replaceable> is given, the default will be
                                <literal>sip</literal>.</para>
			</parameter>
			<parameter name="options">
				<optionlist>
					<option name="c">
						<para>Returns an integer count of the number of NAPTRs of a certain RR type.</para>
						<para>Combination of <literal>c</literal> and Method-type of <literal>ALL</literal> will
						return a count of all NAPTRs for the record.</para>
					</option>
					<option name="u">
						<para>Returns the full URI and does not strip off the URI-scheme.</para>
					</option>
					<option name="s">
						<para>Triggers ISN specific rewriting.</para>
					</option>
					<option name="i">
						<para>Looks for branches into an Infrastructure ENUM tree.</para>
					</option>
					<option name="d">
						<para>for a direct DNS lookup without any flipping of digits.</para>
					</option>
				</optionlist>	
			</parameter>
			<parameter name="record#">
				<para>If no <replaceable>record#</replaceable> is given, 
				defaults to <literal>1</literal>.</para>
			</parameter>
			<parameter name="zone-suffix">
				<para>If no <replaceable>zone-suffix</replaceable> is given, the default will be
				<literal>e164.arpa</literal></para>
			</parameter>
		</syntax>
		<description>
			<para>For more information see <filename>doc/iaxproxy.pdf</filename>.</para>
		</description>
	</function>
	<function name="TXTCIDNAME" language="en_US">
		<synopsis>
			TXTCIDNAME looks up a caller name via DNS.
		</synopsis>
		<syntax>
			<parameter name="number" required="true" />
			<parameter name="zone-suffix">
				<para>If no <replaceable>zone-suffix</replaceable> is given, the default will be
				<literal>e164.arpa</literal></para>
			</parameter>
		</syntax>
		<description>
			<para>This function looks up the given phone number in DNS to retrieve
			the caller id name.  The result will either be blank or be the value
			found in the TXT record in DNS.</para>
		</description>
	</function>
	<function name="ENV" language="en_US">
		<synopsis>
			Gets or sets the environment variable specified.
		</synopsis>
		<syntax>
			<parameter name="varname" required="true">
				<para>Environment variable name</para>
			</parameter>
		</syntax>
		<description>
		</description>
	</function>
	<function name="STAT" language="en_US">
		<synopsis>
			Does a check on the specified file.
		</synopsis>
		<syntax>
			<parameter name="flag" required="true">
				<para>Flag may be one of the following:</para>
				<para>d - Checks if the file is a directory.</para>
				<para>e - Checks if the file exists.</para>
				<para>f - Checks if the file is a regular file.</para>
				<para>m - Returns the file mode (in octal)</para>
				<para>s - Returns the size (in bytes) of the file</para>
				<para>A - Returns the epoch at which the file was last accessed.</para>
				<para>C - Returns the epoch at which the inode was last changed.</para>
				<para>M - Returns the epoch at which the file was last modified.</para>
			</parameter>
			<parameter name="filename" required="true" />
		</syntax>
		<description>
		</description>
	</function>
	<function name="FILE" language="en_US">
		<synopsis>
			Obtains the contents of a file.
		</synopsis>
		<syntax>
			<parameter name="filename" required="true" />
			<parameter name="offset" required="true">
				<para>Maybe specified as any number. If negative, <replaceable>offset</replaceable> specifies the number
				of bytes back from the end of the file.</para>
			</parameter>
			<parameter name="length" required="true">
				<para>If specified, will limit the length of the data read to that size. If negative,
				trims <replaceable>length</replaceable> bytes from the end of the file.</para>
			</parameter>
		</syntax>
		<description>
		</description>
	</function>
	<function name="EXTENSION_STATE" language="en_US">
		<synopsis>
			Get an extension's state.
		</synopsis>	
		<syntax argsep="@">
			<parameter name="extension" required="true" />
			<parameter name="context">
				<para>If it is not specified defaults to <literal>default</literal>.</para>
			</parameter>
		</syntax>
		<description>
			<para>The EXTENSION_STATE function can be used to retrieve the state from any
			hinted extension. For example:</para>
			<para>NoOp(1234@default has state ${EXTENSION_STATE(1234)})</para>
			<para>NoOp(4567@home has state ${EXTENSION_STATE(4567@home)})</para>
			<para>The possible values returned by this function are:</para>
			<para>UNKNOWN | NOT_INUSE | INUSE | BUSY | INVALID | UNAVAILABLE | RINGING |
			RINGINUSE | HOLDINUSE | ONHOLD</para>
		</description>
	</function>
	<function name="GLOBAL" language="en_US">
		<synopsis>
			Gets or sets the global variable specified.
		</synopsis>
		<syntax>
			<parameter name="varname" required="true">
				<para>Global variable name</para>
			</parameter>
		</syntax>
		<description>
			<para>Set or get the value of a global variable specified in <replaceable>varname</replaceable></para>
		</description>
	</function>
	<function name="SHARED" language="en_US">
		<synopsis>
			Gets or sets the shared variable specified.
		</synopsis>
		<syntax>
			<parameter name="varname" required="true">
				<para>Variable name</para>
			</parameter>
			<parameter name="channel">
				<para>If not specified will default to current channel. It is the complete
				channel name: <literal>SIP/12-abcd1234</literal> or the prefix only <literal>SIP/12</literal>.</para>
			</parameter>
		</syntax>
		<description>
			<para>Implements a shared variable area, in which you may share variables between
			channels.</para>
			<para>The variables used in this space are separate from the general namespace of
			the channel and thus <variable>SHARED(foo)</variable> and <variable>foo</variable> 
			represent two completely different variables, despite sharing the same name.</para>
			<para>Finally, realize that there is an inherent race between channels operating
			at the same time, fiddling with each others' internal variables, which is why
			this special variable namespace exists; it is to remind you that variables in
			the SHARED namespace may change at any time, without warning.  You should
			therefore take special care to ensure that when using the SHARED namespace,
			you retrieve the variable and store it in a regular channel variable before
			using it in a set of calculations (or you might be surprised by the result).</para>
		</description>
	</function>

	<function name="GROUP_COUNT" language="en_US">
		<synopsis>
			Counts the number of channels in the specified group.
		</synopsis>
		<syntax argsep="@">
			<parameter name="groupname">
				<para>Group name.</para>
			</parameter>
			<parameter name="category">
				<para>Category name</para>
			</parameter>
		</syntax>
		<description>
			<para>Calculates the group count for the specified group, or uses the
			channel's current group if not specifed (and non-empty).</para>
		</description>
	</function>
	<function name="GROUP_MATCH_COUNT" language="en_US">
		<synopsis>
			Counts the number of channels in the groups matching the specified pattern.
		</synopsis>
		<syntax argsep="@">
			<parameter name="groupmatch" required="true">
				<para>A standard regular expression used to match a group name.</para>
			</parameter>
			<parameter name="category">
				<para>Category name.</para>
			</parameter>
		</syntax>
		<description>
			<para>Calculates the group count for all groups that match the specified pattern.
			Uses standard regular expression matching (see regex(7)).</para>
		</description>
	</function>
	<function name="GROUP" language="en_US">
		<synopsis>
			Gets or sets the channel group.
		</synopsis>
		<syntax>
			<parameter name="category">
				<para>Category name.</para>
			</parameter>
		</syntax>
		<description>
			<para><replaceable>category</replaceable> can be employed for more fine grained group management. Each channel 
			can only be member of exactly one group per <replaceable>category</replaceable>.</para>
		</description>
	</function>
	<function name="GROUP_LIST" language="en_US">
		<synopsis>
			Gets a list of the groups set on a channel.
		</synopsis>
		<syntax />
		<description>
			<para>Gets a list of the groups set on a channel.</para>
		</description>
	</function>

	<function name="ICONV" language="en_US">
		<synopsis>
			Converts charsets of strings.	
		</synopsis>
		<syntax>
			<parameter name="in-charset" required="true">
				<para>Input charset</para>
			</parameter>
			<parameter name="out-charset" required="true">
				<para>Output charset</para>
			</parameter>
			<parameter name="string" required="true">
				<para>String to convert, from <replaceable>in-charset</replaceable> to <replaceable>out-charset</replaceable></para>
			</parameter>
		</syntax>
		<description>
			<para>Converts string from <replaceable>in-charset</replaceable> into <replaceable>out-charset</replaceable>.
			For available charsets, use <literal>iconv -l</literal> on your shell command line.</para>
			<note><para>Due to limitations within the API, ICONV will not currently work with
			charsets with embedded NULLs. If found, the string will terminate.</para></note>
		</description>
	</function>
	<function name="LOCK" language="en_US">
		<synopsis>
			Attempt to obtain a named mutex.
		</synopsis>
		<syntax>
			<parameter name="lockname" required="true" />
		</syntax>
		<description>
			<para>Attempts to grab a named lock exclusively, and prevents other channels from
			obtaining the same lock.  LOCK will wait for the lock to become available.
			Returns <literal>1</literal> if the lock was obtained or <literal>0</literal> on error.</para>
			<note><para>To avoid the possibility of a deadlock, LOCK will only attempt to
			obtain the lock for 3 seconds if the channel already has another lock.</para></note>
		</description>
	</function>
	<function name="TRYLOCK" language="en_US">
		<synopsis>
			Attempt to obtain a named mutex.
		</synopsis>
		<syntax>
			<parameter name="lockname" required="true" />
		</syntax>
		<description>
			<para>Attempts to grab a named lock exclusively, and prevents other channels
			from obtaining the same lock.  Returns <literal>1</literal> if the lock was 
			available or <literal>0</literal> otherwise.</para>
		</description>
	</function>
	<function name="UNLOCK" language="en_US">
		<synopsis>
			Unlocks a named mutex.
		</synopsis>
		<syntax>
			<parameter name="lockname" required="true" />
		</syntax>
		<description>
			<para>Unlocks a previously locked mutex. Returns <literal>1</literal> if the channel 
			had a lock or <literal>0</literal> otherwise.</para>
			<note><para>It is generally unnecessary to unlock in a hangup routine, as any locks 
			held are automatically freed when the channel is destroyed.</para></note>
		</description>
	</function>
	<function name="ISNULL" language="en_US">
		<synopsis>
			Check if a value is NULL.
		</synopsis>
		<syntax>
			<parameter name="data" required="true" />
		</syntax>
		<description>
			<para>Returns <literal>1</literal> if NULL or <literal>0</literal> otherwise.</para>
		</description>
	</function>
	<function name="SET" language="en_US">
		<synopsis>
			SET assigns a value to a channel variable.
		</synopsis>
		<syntax argsep="=">
			<parameter name="varname" required="true" />
			<parameter name="value" />
		</syntax>
		<description>
		</description>
	</function>
	<function name="EXISTS" language="en_US">
		<synopsis>
			Test the existence of a value.
		</synopsis>
		<syntax>
			<parameter name="data" required="true" />
		</syntax>
		<description>
			<para>Returns <literal>1</literal> if exists, <literal>0</literal> otherwise.</para>
		</description>
	</function>
	<function name="IF" language="en_US">
		<synopsis>
			Check for an expresion.
		</synopsis>
		<syntax argsep="?">
			<parameter name="expresion" required="true" />
			<parameter name="retvalue" argsep=":" required="true">
				<argument name="true" />
				<argument name="false" />
			</parameter>
		</syntax>
		<description>
			<para>Returns the data following <literal>?</literal> if true, else the data following <literal>:</literal></para>
		</description>	
	</function>
	<function name="IFTIME" language="en_US">
		<synopsis>
			Temporal Conditional.
		</synopsis>
		<syntax argsep="?">
			<parameter name="timespec" required="true" />
			<parameter name="retvalue" required="true" argsep=":">
				<argument name="true" />
				<argument name="false" />
			</parameter>
		</syntax>
		<description>
			<para>Returns the data following <literal>?</literal> if true, else the data following <literal>:</literal></para>
		</description>
	</function>
	<function name="IMPORT" language="en_US">
		<synopsis>
			Retrieve the value of a variable from another channel.
		</synopsis>
		<syntax>
			<parameter name="channel" required="true" />
			<parameter name="variable" required="true" />
		</syntax>
		<description>
		</description>
	</function>
	<function name="MATH" language="en_US">
		<synopsis>
			Performs Mathematical Functions.
		</synopsis>
		<syntax>
			<parameter name="expression" required="true">
				<para>Is of the form:
				<replaceable>number1</replaceable><replaceable>op</replaceable><replaceable>number2</replaceable>
				where the possible values for <replaceable>op</replaceable>
				are:</para>
				<para>+,-,/,*,%,&lt;&lt;,&gt;&gt;,^,AND,OR,XOR,&lt;,%gt;,&gt;=,&lt;=,== (and behave as their C equivalents)</para>
			</parameter>
			<parameter name="type">
				<para>Wanted type of result:</para>
				<para>f, float - float(default)</para>
				<para>i, int - integer</para>
				<para>h, hex - hex</para>
				<para>c, char - char</para>
			</parameter>
		</syntax>
		<description>
			<para>Performs mathematical functions based on two parameters and an operator.  The returned
			value type is <replaceable>type</replaceable></para>
			<para>Example: Set(i=${MATH(123%16,int)}) - sets var i=11</para>
		</description>
	</function>
	<function name="MD5" language="en_US">
		<synopsis>
			Computes an MD5 digest.
		</synopsis>
		<syntax>
			<parameter name="data" required="true" />
		</syntax>
		<description>
			<para>Computes an MD5 digest.</para>
		</description>
	</function>
	<function name="IFMODULE" language="en_US">
		<synopsis>
			Checks if an Asterisk module is loaded in memory.
		</synopsis>
		<syntax>
			<parameter name="modulename.so" required="true">
				<para>Module name complete with <literal>.so</literal></para>
			</parameter>
		</syntax>
		<description>
			<para>Checks if a module is loaded. Use the full module name
			as shown by the list in <literal>module list</literal>.
			Returns <literal>1</literal> if module exists in memory, otherwise <literal>0</literal></para>
		</description>
	</function>
	<function name="ODBC_FETCH" language="en_US">
		<synopsis>
			Fetch a row from a multirow query.
		</synopsis>
		<syntax>
			<parameter name="result-id" required="true" />
		</syntax>
		<description>
			<para>For queries which are marked as mode=multirow, the original 
			query returns a <replaceable>result-id</replaceable> from which results 
			may be fetched.  This function implements the actual fetch of the results.</para>
			<para>This also sets <variable>ODBC_FETCH_STATUS</variable>.</para>
			<variablelist>
				<variable name="ODBC_FETCH_STATUS">
					<value name="SUCESS">
						If rows are available.
					</value>
					<value name="FAILURE">
						If no rows are available.
					</value>
				</variable>
			</variablelist>
		</description>
	</function>
	<application name="ODBCFinish" language="en_US">
		<synopsis>
			Clear the resultset of a sucessful multirow query.
		</synopsis>
		<syntax>
			<parameter name="result-id" required="true" />
		</syntax>
		<description>
			<para>For queries which are marked as mode=multirow, this will clear 
			any remaining rows of the specified resultset.</para>
		</description>
	</application>
	<function name="SQL_ESC" language="en_US">
		<synopsis>
			Escapes single ticks for use in SQL statements.
		</synopsis>
		<syntax>
			<parameter name="string" required="true" />
		</syntax>
		<description>
			<para>Used in SQL templates to escape data which may contain single ticks 
			<literal>'</literal> which are otherwise used to delimit data.</para>
		  	<para>Example: SELECT foo FROM bar WHERE baz='${SQL_ESC(${ARG1})}'</para>
		</description>
	</function>
	<function name="RAND" language="en_US">
		<synopsis>
			Choose a random number in a range.			
		</synopsis>
		<syntax>
			<parameter name="min" />
			<parameter name="max" />
		</syntax>
		<description>
			<para>Choose a random number between <replaceable>min</replaceable> and <replaceable>max</replaceable>. 
			<replaceable>min</replaceable> defaults to <literal>0</literal>, if not specified, while <replaceable>max</replaceable> defaults 
			to <literal>RAND_MAX</literal> (2147483647 on many systems).</para>
			<para>Example:  Set(junky=${RAND(1,8)});
			Sets junky to a random number between 1 and 8, inclusive.</para>
		</description>
	</function>
	<function name="REALTIME" language="en_US">
		<synopsis>
			RealTime Read/Write Functions.
		</synopsis>
		<syntax>
			<parameter name="family" required="true" />
			<parameter name="fieldmatch" required="true" />
			<parameter name="value" />
			<parameter name="delim1|field">
				<para>Use <replaceable>delim1</replaceable> with <replaceable>delim2</replaceable> on
				read and <replaceable>field</replaceable> without <replaceable>delim2</replaceable> on
				write</para>
				<para>If we are reading and <replaceable>delim1</replaceable> is not specified, defaults
				to <literal>,</literal></para>
			</parameter>
			<parameter name="delim2">
				<para>Parameter only used when reading, if not specified defaults to <literal>=</literal></para>
			</parameter>
		</syntax>
		<description>
			<para>This function will read or write values from/to a RealTime repository.
			REALTIME(....) will read names/values from the repository, and 
			REALTIME(....)= will write a new value/field to the repository. On a
			read, this function returns a delimited text string. The name/value
			pairs are delimited by <replaceable>delim1</replaceable>, and the name and value are delimited
			between each other with delim2. 
			If there is no match, NULL will be returned by the function.
			On a write, this function will always return NULL.</para>
		</description>
	</function>
	<function name="REALTIME_STORE" language="en_US">
		<synopsis>
			RealTime Store Function.
		</synopsis>
		<syntax>
			<parameter name="family" required="true" />
			<parameter name="field1" required="true" />
			<parameter name="fieldN" required="true" multiple="true" />
			<parameter name="field30" required="true" />
		</syntax>
		<description>
			<para>This function will insert a new set of values into the RealTime repository.
			If RT engine provides an unique ID of the stored record, REALTIME_STORE(...)=..
			creates channel variable named RTSTOREID, which contains value of unique ID.
			Currently, a maximum of 30 field/value pairs is supported.</para>
		</description>
	</function>
	<function name="REALTIME_DESTROY" language="en_US">
		<synopsis>
			RealTime Destroy Function.
		</synopsis>
		<syntax>
			<parameter name="family" required="true" />
			<parameter name="fieldmatch" required="true" />
			<parameter name="value" />
			<parameter name="delim1" />
			<parameter name="delim2" />
		</syntax>
		<description>
			<para>This function acts in the same way as REALTIME(....) does, except that
			it destroys the matched record in the RT engine.</para>
		</description>
	</function>
	<function name="REALTIME_FIELD" language="en_US">
		<synopsis>
			RealTime query function.
		</synopsis>
		<syntax>
			<parameter name="family" required="true" />
			<parameter name="fieldmatch" required="true" />
			<parameter name="value" required="true" />
			<parameter name="fieldname" required="true" />
		</syntax>
		<description>
			<para>This function retrieves a single item, <replaceable>fieldname</replaceable>
			from the RT engine, where <replaceable>fieldmatch</replaceable> contains the value
			<replaceable>value</replaceable>.  When written to, the REALTIME_FIELD() function
			performs identically to the REALTIME() function.</para>
		</description>
	</function>
	<function name="REALTIME_HASH" language="en_US">
		<synopsis>
			RealTime query function.
		</synopsis>
		<syntax>
			<parameter name="family" required="true" />
			<parameter name="fieldmatch" required="true" />
			<parameter name="value" required="true" />
		</syntax>
		<description>
			<para>This function retrieves a single record from the RT engine, where
			<replaceable>fieldmatch</replaceable> contains the value
			<replaceable>value</replaceable> and formats the output suitably, such that
			it can be assigned to the HASH() function.  The HASH() function then provides
			a suitable method for retrieving each field value of the record.</para>
		</description>
	</function>
	<function name="SHA1" language="en_US">
		<synopsis>
			Computes a SHA1 digest.
		</synopsis>
		<syntax>
			<parameter name="data" required="true">
				<para>Input string</para>
			</parameter>
		</syntax>
		<description>
			<para>Generate a SHA1 digest via the SHA1 algorythm.</para>
			<para>Example:  Set(sha1hash=${SHA1(junky)})</para>
			<para>Sets the iaxproxy variable sha1hash to the string <literal>60fa5675b9303eb62f99a9cd47f9f5837d18f9a0</literal>
			which is known as his hash</para>	
		</description>
	</function>
	<function name="SHELL" language="en_US">
		<synopsis>
			Executes a command as if you were at a shell.
		</synopsis>
		<syntax>
			<parameter name="command" required="true">
				<para>This is the argument to the function, the command you want to pass to the shell.</para>
			</parameter>
		</syntax>
		<description>
			<para>Returns the value from a system command</para>
			<para>Example:  <literal>Set(foo=${SHELL(echo \bar\)})</literal></para>
			<note><para>When using the SHELL() dialplan function, your \SHELL\ is /bin/sh,
			which may differ as to the underlying shell, depending upon your production
			platform.  Also keep in mind that if you are using a common path, you should
			be mindful of race conditions that could result from two calls running
			SHELL() simultaneously.</para></note>
		</description>
 
	</function>
	<function name="AGC" language="en_US">
		<synopsis>
			Apply automatic gain control to audio on a channel.
		</synopsis>
		<syntax>
			<parameter name="channeldirection" required="true">
				<para>This can be either <literal>rx</literal> or <literal>tx</literal></para>
			</parameter>
		</syntax>
		<description>
			<para>The AGC function will apply automatic gain control to the audio on the
			channel that it is executed on. Using <literal>rx</literal> for audio received
			and <literal>tx</literal> for audio transmitted to the channel. When using this
			function you set a target audio level. It is primarily intended for use with
			analog lines, but could be useful for other channels as well. The target volume 
			is set with a number between <literal>1-32768</literal>. The larger the number
			the louder (more gain) the channel will receive.</para>
			<para>Examples:</para>
			<para>exten => 1,1,Set(AGC(rx)=8000)</para>
			<para>exten => 1,2,Set(AGC(tx)=off)</para>
		</description>
	</function>
	<function name="DENOISE" language="en_US">
		<synopsis>
			Apply noise reduction to audio on a channel.
		</synopsis>
		<syntax>
			<parameter name="channeldirection" required="true">
				<para>This can be either <literal>rx</literal> or <literal>tx</literal> 
				the values that can be set to this are either <literal>on</literal> and
				<literal>off</literal></para>
			</parameter>
		</syntax>
		<description>
			<para>The DENOISE function will apply noise reduction to audio on the channel
			that it is executed on. It is very useful for noisy analog lines, especially
			when adjusting gains or using AGC. Use <literal>rx</literal> for audio received from the channel
			and <literal>tx</literal> to apply the filter to the audio being sent to the channel.</para>
			<para>Examples:</para>
			<para>exten => 1,1,Set(DENOISE(rx)=on)</para>
			<para>exten => 1,2,Set(DENOISE(tx)=off)</para>
		</description>
	</function>
	<function name="SPRINTF" language="en_US">
		<synopsis>
			Format a variable according to a format string.
		</synopsis>
		<syntax>
			<parameter name="format" required="true" />
			<parameter name="arg1" required="true" />
			<parameter name="arg2" multiple="true" />
			<parameter name="argN" />
		</syntax>
		<description>
			<para>Parses the format string specified and returns a string matching 
			that format. Supports most options found in <emphasis>sprintf(3)</emphasis>.
			Returns a shortened string if a format specifier is not recognized.</para>
		</description>
		<see-also>
			<ref type="manpage">sprintf(3)</ref>
		</see-also>
	</function>
	<function name="FIELDQTY" language="en_US">
		<synopsis>
			Count the fields with an arbitrary delimiter
		</synopsis>
		<syntax>
			<parameter name="varname" required="true" />
			<parameter name="delim" required="true" />
		</syntax>
		<description>
			<para>The delimiter may be specified as a special or extended ASCII character, by encoding it.  The characters
			<literal>\n</literal>, <literal>\r</literal>, and <literal>\t</literal> are all recognized as the newline,
			carriage return, and tab characters, respectively.  Also, octal and hexadecimal specifications are recognized
			by the patterns <literal>\0nnn</literal> and <literal>\xHH</literal>, respectively.  For example, if you wanted
			to encode a comma as the delimiter, you could use either <literal>\054</literal> or <literal>\x2C</literal>.</para>
			<para>Example: If ${example} contains <literal>ex-amp-le</literal>, then ${FIELDQTY(example,-)} returns 3.</para>
		</description>
	</function>
	<function name="LISTFILTER" language="en_US">
		<synopsis>Remove an item from a list, by name.</synopsis>
		<syntax>
			<parameter name="varname" required="true" />
			<parameter name="delim" required="true" default="," />
			<parameter name="value" required="true" />
		</syntax>
		<description>
			<para>Remove <replaceable>value</replaceable> from the list contained in the <replaceable>varname</replaceable>
			variable, where the list delimiter is specified by the <replaceable>delim</replaceable> parameter.  This is
			very useful for removing a single channel name from a list of channels, for example.</para>
		</description>
	</function>
	<function name="FILTER" language="en_US">
		<synopsis>
			Filter the string to include only the allowed characters
		</synopsis>
		<syntax>
			<parameter name="allowed-chars" required="true" />
			<parameter name="string" required="true" />
		</syntax>
		<description>
			<para>Permits all characters listed in <replaceable>allowed-chars</replaceable>, 
			filtering all others outs. In addition to literally listing the characters, 
			you may also use ranges of characters (delimited by a <literal>-</literal></para>
			<para>Hexadecimal characters started with a <literal>\x</literal>(i.e. \x20)</para>
			<para>Octal characters started with a <literal>\0</literal> (i.e. \040)</para>
			<para>Also <literal>\t</literal>,<literal>\n</literal> and <literal>\r</literal> are recognized.</para> 
			<note><para>If you want the <literal>-</literal> character it needs to be prefixed with a 
			<literal>\</literal></para></note>
		</description>
	</function>
	<function name="REGEX" language="en_US">
		<synopsis>
			Check string against a regular expression.
		</synopsis>
		<syntax argsep=" ">
			<parameter name="&quot;regular expression&quot;" required="true" />
			<parameter name="string" required="true" />
		</syntax>
		<description>
			<para>Return <literal>1</literal> on regular expression match or <literal>0</literal> otherwise</para>
			<para>Please note that the space following the double quotes separating the 
			regex from the data is optional and if present, is skipped. If a space is 
			desired at the beginning of the data, then put two spaces there; the second 
			will not be skipped.</para>
		</description>
	</function>
	<application name="ClearHash" language="en_US">
		<synopsis>
			Clear the keys from a specified hashname.
		</synopsis>
		<syntax>
			<parameter name="hashname" required="true" />
		</syntax>
		<description>
			<para>Clears all keys out of the specified <replaceable>hashname</replaceable>.</para>
		</description>
	</application>
	<function name="HASH" language="en_US">
		<synopsis>
			Implementation of a dialplan associative array
		</synopsis>
		<syntax>
			<parameter name="hashname" required="true" />
			<parameter name="hashkey" />
		</syntax>
		<description>
			<para>In two arguments mode, gets and sets values to corresponding keys within
			a named associative array. The single-argument mode will only work when assigned
			to from a function defined by func_odbc</para>
		</description>
	</function>
	<function name="HASHKEYS" language="en_US">
		<synopsis>
			Retrieve the keys of the HASH() function.
		</synopsis>
		<syntax>
			<parameter name="hashname" required="true" />
		</syntax>
		<description>
			<para>Returns a comma-delimited list of the current keys of the associative array 
			defined by the HASH() function. Note that if you iterate over the keys of 
			the result, adding keys during iteration will cause the result of the HASHKEYS()
			function to change.</para>
		</description>
	</function>
	<function name="KEYPADHASH" language="en_US">
		<synopsis>
			Hash the letters in string into equivalent keypad numbers.
		</synopsis>
		<syntax>
			<parameter name="string" required="true" />
		</syntax>
		<description>
			<para>Example: ${KEYPADHASH(Les)} returns "537"</para>
		</description>
	</function>
	<function name="ARRAY" language="en_US">
		<synopsis>
			Allows setting multiple variables at once.
		</synopsis>
		<syntax>
			<parameter name="var1" required="true" />
			<parameter name="var2" required="false" multiple="true" />
			<parameter name="varN" required="false" />
		</syntax>
		<description>
			<para>The comma-delimited list passed as a value to which the function is set will 
			be interpreted as a set of values to which the comma-delimited list of 
			variable names in the argument should be set.</para>
			<para>Example: Set(ARRAY(var1,var2)=1,2) will set var1 to 1 and var2 to 2</para>
		</description>
	</function>
	<function name="STRPTIME" language="en_US">
		<synopsis>
			Returns the epoch of the arbitrary date/time string structured as described by the format.
		</synopsis>
		<syntax>
			<parameter name="datetime" required="true" />
			<parameter name="timezone" required="true" />
			<parameter name="format" required="true" />
		</syntax>
		<description>
			<para>This is useful for converting a date into <literal>EPOCH</literal> time, 
			possibly to pass to an application like SayUnixTime or to calculate the difference
			between the two date strings</para>
			<para>Example: ${STRPTIME(2006-03-01 07:30:35,America/Chicago,%Y-%m-%d %H:%M:%S)} returns 1141219835</para>
		</description>
	</function>
	<function name="STRFTIME" language="en_US">
		<synopsis>
			Returns the current date/time in the specified format.
		</synopsis>
		<syntax>
			<parameter name="epoch" />
			<parameter name="timezone" />
			<parameter name="format" />
		</syntax>
		<description>
			<para>STRFTIME supports all of the same formats as the underlying C function
			<emphasis>strftime(3)</emphasis>.
			It also supports the following format: <literal>%[n]q</literal> - fractions of a second,
			with leading zeros.</para>
			<para>Example: <literal>%3q</literal> will give milliseconds and <literal>%1q</literal>
			will give tenths of a second. The default is set at milliseconds (n=3).
			The common case is to use it in combination with %S, as in <literal>%S.%3q</literal>.</para>
		</description>
		<see-also>
			<ref type="manpage">strftime(3)</ref>
		</see-also>
	</function>
	<function name="EVAL" language="en_US">
		<synopsis>
			Evaluate stored variables
		</synopsis>
		<syntax>
			<parameter name="variable" required="true" />
		</syntax>
		<description>
			<para>Using EVAL basically causes a string to be evaluated twice.
			When a variable or expression is in the dialplan, it will be
			evaluated at runtime. However, if the results of the evaluation
			is in fact another variable or expression, using EVAL will have it
			evaluated a second time.</para>
			<para>Example: If the <variable>MYVAR</variable> contains
			<variable>OTHERVAR</variable>, then the result of ${EVAL(
			<variable>MYVAR</variable>)} in the dialplan will be the
			contents of <variable>OTHERVAR</variable>. Normally just
			putting <variable>MYVAR</variable> in the dialplan the result
			would be <variable>OTHERVAR</variable>.</para>
		</description>
	</function>
	<function name="TOUPPER" language="en_US">
		<synopsis>
			Convert string to all uppercase letters.
		</synopsis>
		<syntax>
			<parameter name="string" required="true" />
		</syntax>
		<description>
			<para>Example: ${TOUPPER(Example)} returns "EXAMPLE"</para>
		</description>
	</function>
	<function name="TOLOWER" language="en_US">
		<synopsis>
			Convert string to all lowercase letters.
		</synopsis>
		<syntax>
			<parameter name="string" required="true" />
		</syntax>
		<description>
			<para>Example: ${TOLOWER(Example)} returns "example"</para>
		</description>
	</function>
	<function name="LEN" language="en_US">
		<synopsis>
			Return the length of the string given.
		</synopsis>
		<syntax>
			<parameter name="string" required="true" />
		</syntax>
		<description>
			<para>Example: ${LEN(example)} returns 7</para>
		</description>
	</function>
	<function name="QUOTE" language="en_US">
		<synopsis>
			Quotes a given string, escaping embedded quotes as necessary
		</synopsis>
		<syntax>
			<parameter name="string" required="true" />
		</syntax>
		<description>
			<para>Example: ${QUOTE(ab"c"de)} will return "abcde"</para>
		</description>
	</function>
	<function name="CSV_QUOTE" language="en_US">
		<synopsis>
			Quotes a given string for use in a CSV file, escaping embedded quotes as necessary
		</synopsis>
		<syntax>
			<parameter name="string" required="true" />
		</syntax>
		<description>
			<para>Example: ${CSV_QUOTE("a,b" 123)} will return """a,b"" 123"</para>
		</description>
	</function>
	<function name="TIMEOUT" language="en_US">
		<synopsis>
			Gets or sets timeouts on the channel. Timeout values are in seconds.
		</synopsis>
		<syntax>
			<parameter name="timeouttype" required="true">
				<para>The timeout that will be manipulated. The possible timeout types
				are: <literal>absolute</literal>, <literal>digit</literal> or 
				<literal>response</literal></para>
			</parameter>
		</syntax>
		<description>
			<para>The timeouts that can be manipulated are:</para>
			<para><literal>absolute</literal>: The absolute maximum amount of time permitted for a call.
			Setting of 0 disables the timeout.</para>
			<para><literal>digit</literal>: The maximum amount of time permitted between digits when the
			user is typing in an extension.  When this timeout expires,
			after the user has started to type in an extension, the
			extension will be considered complete, and will be
			interpreted.  Note that if an extension typed in is valid,
			it will not have to timeout to be tested, so typically at
			the expiry of this timeout, the extension will be considered
			invalid (and thus control would be passed to the <literal>i</literal>
			extension, or if it doesn't exist the call would be
			terminated).  The default timeout is 5 seconds.</para>
			<para><literal>response</literal>: The maximum amount of time permitted after falling through a
			series of priorities for a channel in which the user may
			begin typing an extension.  If the user does not type an
			extension in this amount of time, control will pass to the
			<literal>t</literal> extension if it exists, and if not the call would be
			terminated.  The default timeout is 10 seconds.</para>
		</description>
	</function>
	<function name="URIENCODE" language="en_US">
		<synopsis>
			Encodes a string to URI-safe encoding according to RFC 2396.
		</synopsis>
		<syntax>
			<parameter name="data" required="true">
				<para>Input string to be encoded.</para>
			</parameter>
		</syntax>
		<description>
			<para>Returns the encoded string defined in <replaceable>data</replaceable>.</para>
		</description>
	</function>
	<function name="URIDECODE" language="en_US">
		<synopsis>
			Decodes a URI-encoded string according to RFC 2396.
		</synopsis>
		<syntax>
			<parameter name="data" required="true">
				<para>Input string to be decoded.</para>
			</parameter>
		</syntax>
		<description>
			<para>Returns the decoded URI-encoded <replaceable>data</replaceable> string.</para>
		</description>
	</function>
	<function name="VERSION" language="en_US">
		<synopsis>
			Return the Version info for this Asterisk.
		</synopsis>
		<syntax>
			<parameter name="info">
				<para>The possible values are:</para>
				<enumlist>
					<enum name="ASTERISK_VERSION_NUM">
						<para>A string of digits is returned (right now fixed at 999999).</para>
					</enum>
					<enum name="BUILD_USER">
						<para>The string representing the user's name whose account
						was used to configure Asterisk, is returned.</para>
					</enum>
					<enum name="BUILD_HOSTNAME">
						<para>The string representing the name of the host on which Asterisk was configured, is returned.</para>
					</enum>
					<enum name="BUILD_MACHINE">
						<para>The string representing the type of machine on which Asterisk was configured, is returned.</para>
					</enum>
					<enum name="BUILD_OS">
						<para>The string representing the OS of the machine on which Asterisk was configured, is returned.</para>
					</enum>
					<enum name="BUILD_DATE">
						<para>The string representing the date on which Asterisk was configured, is returned.</para>
					</enum>
					<enum name="BUILD_KERNEL">
						<para>The string representing the kernel version of the machine on which Asterisk
						was configured, is returned.</para>
					</enum>
				</enumlist>
			</parameter>
		</syntax>
		<description>
			<para>If there are no arguments, return the version of Asterisk in this format: SVN-branch-1.4-r44830M</para>
			<para>Example:  Set(junky=${VERSION()};</para>
			<para>Sets junky to the string <literal>SVN-branch-1.6-r74830M</literal>, or possibly, <literal>SVN-trunk-r45126M</literal>.</para>
		</description>
	</function>
	<function name="VMCOUNT" language="en_US">
		<synopsis>
			Count the voicemails in a specified mailbox.
		</synopsis>
		<syntax>
			<parameter name="vmbox" required="true" argsep="@">
				<argument name="vmbox" required="true" />
				<argument name="context" required="false">
					<para>If not specified, defaults to <literal>default</literal>.</para>
				</argument>
			</parameter>
			<parameter name="folder" required="false">
				<para>If not specified, defaults to <literal>INBOX</literal></para>
			</parameter>
		</syntax>
		<description>
			<para>Count the number of voicemails in a specified mailbox, you could also specify 
			the <replaceable>context</replaceable> and the mailbox <replaceable>folder</replaceable>.</para>
			<para>Example: <literal>exten => s,1,Set(foo=${VMCOUNT(125)})</literal></para>
		</description>
	</function>
	<function name="VOLUME" language="en_US">
		<synopsis>
			Set the TX or RX volume of a channel.
		</synopsis>
		<syntax>
			<parameter name="direction" required="true">
				<para>Must be <literal>TX</literal> or <literal>RX</literal>.</para>
			</parameter>
			<parameter name="options">
				<optionlist>
					<option name="p">
						<para>Enable DTMF volume control</para>
					</option>
				</optionlist>
			</parameter>
		</syntax>
		<description>
			<para>The VOLUME function can be used to increase or decrease the <literal>tx</literal> or
			<literal>rx</literal> gain of any channel.</para>
			<para>For example:</para>
			<para>Set(VOLUME(TX)=3)</para>
			<para>Set(VOLUME(RX)=2)</para>
			<para>Set(VOLUME(TX,p)=3)</para>
			<para>Set(VOLUME(RX,p)=3></para>
		</description>
	</function>
	<application name="Bridge" language="en_US">
		<synopsis>
			Bridge two channels.
		</synopsis>
		<syntax>
			<parameter name="channel" required="true">
				<para>The current channel is bridged to the specified <replaceable>channel</replaceable>.</para>
			</parameter>
			<parameter name="options">
				<optionlist>
					<option name="p">
						<para>Play a courtesy tone to <replaceable>channel</replaceable>.</para>
					</option>
				</optionlist>
			</parameter>
		</syntax>
		<description>
			<para>Allows the ability to bridge two channels via the dialplan.</para>
			<para>This application sets the following channel variable upon completion:</para>
			<variablelist>
				<variable name="BRIDGERESULT">
					<para>The result of the bridge attempt as a text string.</para>
					<value name="SUCCESS" />
					<value name="FAILURE" />
					<value name="LOOP" />
					<value name="NONEXISTENT" />
					<value name="INCOMPATIBLE" />
				</variable>
			</variablelist>
		</description>
	</application>
	<application name="ParkedCall" language="en_US">
		<synopsis>
			Answer a parked call.
		</synopsis>
		<syntax>
			<parameter name="exten" required="true" />
		</syntax>
		<description>
			<para>Used to connect to a parked call. This application is always
			registered internally and does not need to be explicitly added
			into the dialplan, although you should include the <literal>parkedcalls</literal>
			context. If no extension is provided, then the first available
			parked call will be acquired.</para>
		</description>
		<see-also>
			<ref type="application">Park</ref>
			<ref type="application">ParkAndAnnounce</ref>
		</see-also>
	</application>
	<application name="Park" language="en_US">
		<synopsis>
			Park yourself.
		</synopsis>
		<syntax>
			<parameter name="timeout">
				<para>A custom parking timeout for this parked call. Value in milliseconds.</para>
			</parameter>
			<parameter name="return_context">
				<para>The context to return the call to after it times out.</para>
			</parameter>
			<parameter name="return_exten">
				<para>The extension to return the call to after it times out.</para>
			</parameter>
			<parameter name="return_priority">
				<para>The priority to return the call to after it times out.</para>
			</parameter>
			<parameter name="options">
				<para>A list of options for this parked call.</para>
				<optionlist>
					<option name="r">
						<para>Send ringing instead of MOH to the parked call.</para>
					</option>
					<option name="R">
						<para>Randomize the selection of a parking space.</para>
					</option>
					<option name="s">
						<para>Silence announcement of the parking space number.</para>
					</option>
				</optionlist>
			</parameter>
		</syntax>
		<description>
			<para>Used to park yourself (typically in combination with a supervised
			transfer to know the parking space). This application is always
			registered internally and does not need to be explicitly added
			into the dialplan, although you should include the <literal>parkedcalls</literal>
			context (or the context specified in <filename>features.conf</filename>).</para>
			<para>If you set the <variable>PARKINGLOT</variable> variable, the call will be parked
			in the specifed parking context. Note setting this variable overrides the <variable>
			PARKINGLOT</variable> set by the <literal>CHANNEL</literal> function.</para>
			<para>If you set the <variable>PARKINGEXTEN</variable> variable to an extension in your
			parking context, Park() will park the call on that extension, unless
			it already exists. In that case, execution will continue at next priority.</para>
		</description>
		<see-also>
			<ref type="application">ParkAndAnnounce</ref>
			<ref type="application">ParkedCall</ref>
		</see-also>
	</application>
	<application name="Answer" language="en_US">
		<synopsis>
			Answer a channel if ringing.
		</synopsis>
		<syntax>
			<parameter name="delay">
				<para>Asterisk will wait this number of milliseconds before returning to
				the dialplan after answering the call.</para>
			</parameter>
			<parameter name="nocdr">
				<para>Asterisk will send an answer signal to the calling phone, but will not
				set the disposition or answer time in the CDR for this call.</para>
			</parameter>
		</syntax>
		<description>
			<para>If the call has not been answered, this application will
			answer it. Otherwise, it has no effect on the call.</para>
		</description>
		<see-also>
			<ref type="application">Hangup</ref>
		</see-also>
	</application>
	<application name="BackGround" language="en_US">
		<synopsis>
			Play an audio file while waiting for digits of an extension to go to.
		</synopsis>
		<syntax>
			<parameter name="filenames" required="true" argsep="&amp;">
				<argument name="filename1" required="true" />
				<argument name="filename2" multiple="true" />
			</parameter>
			<parameter name="options">
				<optionlist>
					<option name="s">
						<para>Causes the playback of the message to be skipped
						if the channel is not in the <literal>up</literal> state (i.e. it
						hasn't been answered yet). If this happens, the
						application will return immediately.</para>
					</option>
					<option name="n">
						<para>Don't answer the channel before playing the files.</para>
					</option>
					<option name="m">
						<para>Only break if a digit hit matches a one digit
						extension in the destination context.</para>
					</option>
				</optionlist>
			</parameter>
			<parameter name="langoverride">
				<para>Explicitly specifies which language to attempt to use for the requested sound files.</para>
			</parameter>
			<parameter name="context">
				<para>This is the dialplan context that this application will use when exiting
				to a dialed extension.</para>
			</parameter>
		</syntax>
		<description>
			<para>This application will play the given list of files <emphasis>(do not put extension)</emphasis>
			while waiting for an extension to be dialed by the calling channel. To continue waiting
			for digits after this application has finished playing files, the <literal>WaitExten</literal>
			application should be used.</para>
			<para>If one of the requested sound files does not exist, call processing will be terminated.</para>
			<para>This application sets the following channel variable upon completion:</para>
			<variablelist>
				<variable name="BACKGROUNDSTATUS">
					<para>The status of the background attempt as a text string.</para>
					<value name="SUCCESS" />
					<value name="FAILED" />
				</variable>
			</variablelist>
		</description>
		<see-also>
			<ref type="application">ControlPlayback</ref>
			<ref type="application">WaitExten</ref>
			<ref type="application">BackgroundDetect</ref>
			<ref type="function">TIMEOUT</ref>
		</see-also>
	</application>
	<application name="Busy" language="en_US">
		<synopsis>
			Indicate the Busy condition.
		</synopsis>
		<syntax>
			<parameter name="timeout">
				<para>If specified, the calling channel will be hung up after the specified number of seconds.
				Otherwise, this application will wait until the calling channel hangs up.</para>
			</parameter>
		</syntax>
		<description>
			<para>This application will indicate the busy condition to the calling channel.</para>
		</description>
		<see-also>
			<ref type="application">Congestion</ref>
			<ref type="application">Progess</ref>
			<ref type="application">Playtones</ref>
			<ref type="application">Hangup</ref>
		</see-also>
	</application>
	<application name="Congestion" language="en_US">
		<synopsis>
			Indicate the Congestion condition.
		</synopsis>
		<syntax>
			<parameter name="timeout">
				<para>If specified, the calling channel will be hung up after the specified number of seconds.
				Otherwise, this application will wait until the calling channel hangs up.</para>
			</parameter>
		</syntax>
		<description>
			<para>This application will indicate the congestion condition to the calling channel.</para>
		</description>
		<see-also>
			<ref type="application">Busy</ref>
			<ref type="application">Progess</ref>
			<ref type="application">Playtones</ref>
			<ref type="application">Hangup</ref>
		</see-also>
	</application>
	<application name="ExecIfTime" language="en_US">
		<synopsis>
			Conditional application execution based on the current time.
		</synopsis>
		<syntax argsep="?">
			<parameter name="day_condition" required="true">
				<argument name="times" required="true" />
				<argument name="weekdays" required="true" />
				<argument name="mdays" required="true" />
				<argument name="months" required="true" />
				<argument name="timezone" required="false" />
			</parameter>
			<parameter name="appname" required="true" hasparams="optional">
				<argument name="appargs" required="true" />
			</parameter>
		</syntax>
		<description>
			<para>This application will execute the specified dialplan application, with optional
			arguments, if the current time matches the given time specification.</para>
		</description>
		<see-also>
			<ref type="application">Exec</ref>
			<ref type="application">TryExec</ref>
		</see-also>
	</application>
	<application name="Goto" language="en_US">
		<synopsis>
			Jump to a particular priority, extension, or context.
		</synopsis>
		<syntax>
			<parameter name="context" />
			<parameter name="extensions" />
			<parameter name="priority" required="true" />
		</syntax>
		<description>
			<para>This application will set the current context, extension, and priority in the channel structure.
			After it completes, the pbx engine will continue dialplan execution at the specified location.
			If no specific <replaceable>extension</replaceable>, or <replaceable>extension</replaceable> and
			<replaceable>context</replaceable>, are specified, then this application will
			just set the specified <replaceable>priority</replaceable> of the current extension.</para>
			<para>At least a <replaceable>priority</replaceable> is required as an argument, or the goto will
			return a <literal>-1</literal>,	and the channel and call will be terminated.</para>
			<para>If the location that is put into the channel information is bogus, and iaxproxy cannot
			find that location in the dialplan, then the execution engine will try to find and execute the code in
			the <literal>i</literal> (invalid) extension in the current context. If that does not exist, it will try to execute the
			<literal>h</literal> extension. If either or neither the <literal>h</literal> or <literal>i</literal> extensions
			have been defined, the channel is hung up, and the execution of instructions on the channel is terminated.
			What this means is that, for example, you specify a context that does not exist, then
			it will not be possible to find the <literal>h</literal> or <literal>i</literal> extensions,
			and the call will terminate!</para>
		</description>
		<see-also>
			<ref type="application">GotoIf</ref>
			<ref type="application">GotoIfTime</ref>
			<ref type="application">Gosub</ref>
			<ref type="application">Macro</ref>
		</see-also>
	</application>
	<application name="GotoIf" language="en_US">
		<synopsis>
			Conditional goto.
		</synopsis>
		<syntax argsep="?">
			<parameter name="condition" required="true" />
			<parameter name="destination" required="true" argsep=":">
				<argument name="labeliftrue">
					<para>Continue at <replaceable>labeliftrue</replaceable> if the condition is true.</para>
				</argument>
				<argument name="labeliffalse">
					<para>Continue at <replaceable>labeliffalse</replaceable> if the condition is false.</para>
				</argument>
			</parameter>
		</syntax>
		<description>
			<para>This application will set the current context, extension, and priority in the channel structure
			based on the evaluation of the given condition. After this application completes, the
			pbx engine will continue dialplan execution at the specified location in the dialplan.
			The labels are specified with the same syntax as used within the Goto application.
			If the label chosen by the condition is omitted, no jump is performed, and the execution passes to the
			next instruction. If the target location is bogus, and does not exist, the execution engine will try
			to find and execute the code in the <literal>i</literal> (invalid) extension in the current context.
			If that does not exist, it will try to execute the <literal>h</literal> extension.
			If either or neither the <literal>h</literal> or <literal>i</literal> extensions have been defined,
			the channel is hung up, and the execution of instructions on the channel is terminated.
			Remember that this command can set the current context, and if the context specified
			does not exist, then it will not be able to find any 'h' or 'i' extensions there, and
			the channel and call will both be terminated!.</para>
		</description>
		<see-also>
			<ref type="application">Goto</ref>
			<ref type="application">GotoIfTime</ref>
			<ref type="application">GosubIf</ref>
			<ref type="application">MacroIf</ref>
		</see-also>
	</application>
	<application name="GotoIfTime" language="en_US">
		<synopsis>
			Conditional Goto based on the current time.
		</synopsis>
		<syntax argsep="?">
			<parameter name="condition" required="true">
				<argument name="times" required="true" />
				<argument name="weekdays" required="true" />
				<argument name="mdays" required="true" />
				<argument name="months" required="true" />
				<argument name="timezone" required="false" />
			</parameter>
			<parameter name="destination" required="true" argsep=":">
				<argument name="labeliftrue" />
				<argument name="labeliffalse" />
			</parameter>
		</syntax>
		<description>
			<para>This application will set the context, extension, and priority in the channel structure
			based on the evaluation of the given time specification. After this application completes,
			the pbx engine will continue dialplan execution at the specified location in the dialplan.
			If the current time is within the given time specification, the channel will continue at
			<replaceable>labeliftrue</replaceable>. Otherwise the channel will continue at <replaceable>labeliffalse</replaceable>.
			If the label chosen by the condition is omitted, no jump is performed, and execution passes to the next
			instruction. If the target jump location is bogus, the same actions would be taken as for <literal>Goto</literal>.
			Further information on the time specification can be found in examples
			illustrating how to do time-based context includes in the dialplan.</para>
		</description>
		<see-also>
			<ref type="application">GotoIf</ref>
			<ref type="function">IFTIME</ref>
		</see-also>
	</application>
	<application name="ImportVar" language="en_US">
		<synopsis>
			Import a variable from a channel into a new variable.
		</synopsis>
		<syntax argsep="=">
			<parameter name="newvar" required="true" />
			<parameter name="vardata" required="true">
				<argument name="channelname" required="true" />
				<argument name="variable" required="true" />
			</parameter>
		</syntax>
		<description>
			<para>This application imports a <replaceable>variable</replaceable> from the specified
			<replaceable>channel</replaceable> (as opposed to the current one) and stores it as a variable
			(<replaceable>newvar</replaceable>) in the current channel (the channel that is calling this
			application). Variables created by this application have the same inheritance properties as those
			created with the <literal>Set</literal> application.</para>
		</description>
		<see-also>
			<ref type="application">Set</ref>
		</see-also>
	</application>
	<application name="Hangup" language="en_US">
		<synopsis>
			Hang up the calling channel.
		</synopsis>
		<syntax>
			<parameter name="causecode">
				<para>If a <replaceable>causecode</replaceable> is given the channel's
				hangup cause will be set to the given value.</para>
			</parameter>
		</syntax>
		<description>
			<para>This application will hang up the calling channel.</para>
		</description>
		<see-also>
			<ref type="application">Answer</ref>
			<ref type="application">Busy</ref>
			<ref type="application">Congestion</ref>
		</see-also>
	</application>
	<application name="Incomplete" language="en_US">
		<synopsis>
			Returns AST_PBX_INCOMPLETE value.
		</synopsis>
		<syntax>
			<parameter name="n">
				<para>If specified, then Incomplete will not attempt to answer the channel first.</para>
				<note><para>Most channel types need to be in Answer state in order to receive DTMF.</para></note>
			</parameter>
		</syntax>
		<description>
			<para>Signals the PBX routines that the previous matched extension is incomplete
			and that further input should be allowed before matching can be considered
			to be complete.  Can be used within a pattern match when certain criteria warrants
			a longer match.</para>
		</description>
	</application>
	<application name="NoOp" language="en_US">
		<synopsis>
			Do Nothing (No Operation).
		</synopsis>
		<syntax>
			<parameter name="text">
				<para>Any text provided can be viewed at the Asterisk CLI.</para>
			</parameter>
		</syntax>
		<description>
			<para>This application does nothing. However, it is useful for debugging purposes.</para>
			<para>This method can be used to see the evaluations of variables or functions without having any effect.</para>
		</description>
		<see-also>
			<ref type="application">Verbose</ref>
			<ref type="application">Log</ref>
		</see-also>
	</application>
	<application name="Proceeding" language="en_US">
		<synopsis>
			Indicate proceeding.
		</synopsis>
		<syntax />
		<description>
			<para>This application will request that a proceeding message be provided to the calling channel.</para>
		</description>
	</application>
	<application name="Progress" language="en_US">
		<synopsis>
			Indicate progress.
		</synopsis>
		<syntax />
		<description>
			<para>This application will request that in-band progress information be provided to the calling channel.</para>
		</description>
		<see-also>
			<ref type="application">Busy</ref>
			<ref type="application">Congestion</ref>
			<ref type="application">Ringing</ref>
			<ref type="application">Playtones</ref>
		</see-also>
	</application>
	<application name="RaiseException" language="en_US">
		<synopsis>
			Handle an exceptional condition.
		</synopsis>
		<syntax>
			<parameter name="reason" required="true" />
		</syntax>
		<description>
			<para>This application will jump to the <literal>e</literal> extension in the current context, setting the
			dialplan function EXCEPTION(). If the <literal>e</literal> extension does not exist, the call will hangup.</para>
		</description>
		<see-also>
			<ref type="function">Exception</ref>
		</see-also>
	</application>
	<application name="ResetCDR" language="en_US">
		<synopsis>
			Resets the Call Data Record.
		</synopsis>
		<syntax>
			<parameter name="options">
				<optionlist>
					<option name="w">
						<para>Store the current CDR record before resetting it.</para>
					</option>
					<option name="a">
						<para>Store any stacked records.</para>
					</option>
					<option name="v">
						<para>Save CDR variables.</para>
					</option>
					<option name="e">
						<para>Enable CDR only (negate effects of NoCDR).</para>
					</option>
				</optionlist>
			</parameter>
		</syntax>
		<description>
			<para>This application causes the Call Data Record to be reset.</para>
		</description>
		<see-also>
			<ref type="application">ForkCDR</ref>
			<ref type="application">NoCDR</ref>
		</see-also>
	</application>
	<application name="Ringing" language="en_US">
		<synopsis>
			Indicate ringing tone.
		</synopsis>
		<syntax />
		<description>
			<para>This application will request that the channel indicate a ringing tone to the user.</para>
		</description>
		<see-also>
			<ref type="application">Busy</ref>
			<ref type="application">Congestion</ref>
			<ref type="application">Progress</ref>
			<ref type="application">Playtones</ref>
		</see-also>
	</application>
	<application name="SayAlpha" language="en_US">
		<synopsis>
			Say Alpha.
		</synopsis>
		<syntax>
			<parameter name="string" required="true" />
		</syntax>
		<description>
			<para>This application will play the sounds that correspond to the letters of the
			given <replaceable>string</replaceable>.</para>
		</description>
		<see-also>
			<ref type="application">SayDigits</ref>
			<ref type="application">SayNumber</ref>
			<ref type="application">SayPhonetic</ref>
			<ref type="function">CHANNEL</ref>
		</see-also>
	</application>
	<application name="SayDigits" language="en_US">
		<synopsis>
			Say Digits.
		</synopsis>
		<syntax>
			<parameter name="digits" required="true" />
		</syntax>
		<description>
			<para>This application will play the sounds that correspond to the digits of
			the given number. This will use the language that is currently set for the channel.</para>
		</description>
		<see-also>
			<ref type="application">SayAlpha</ref>
			<ref type="application">SayNumber</ref>
			<ref type="application">SayPhonetic</ref>
			<ref type="function">CHANNEL</ref>
		</see-also>
	</application>
	<application name="SayNumber" language="en_US">
		<synopsis>
			Say Number.
		</synopsis>
		<syntax>
			<parameter name="digits" required="true" />
			<parameter name="gender" />
		</syntax>
		<description>
			<para>This application will play the sounds that correspond to the given <replaceable>digits</replaceable>.
			Optionally, a <replaceable>gender</replaceable> may be specified. This will use the language that is currently
			set for the channel. See the LANGUAGE() function for more information on setting the language for the channel.</para>
		</description>
		<see-also>
			<ref type="application">SayAlpha</ref>
			<ref type="application">SayDigits</ref>
			<ref type="application">SayPhonetic</ref>
			<ref type="function">CHANNEL</ref>
		</see-also>
	</application>
	<application name="SayPhonetic" language="en_US">
		<synopsis>
			Say Phonetic.
		</synopsis>
		<syntax>
			<parameter name="string" required="true" />
		</syntax>
		<description>
			<para>This application will play the sounds from the phonetic alphabet that correspond to the
			letters in the given <replaceable>string</replaceable>.</para>
		</description>
		<see-also>
			<ref type="application">SayAlpha</ref>
			<ref type="application">SayDigits</ref>
			<ref type="application">SayNumber</ref>
		</see-also>
	</application>
	<application name="Set" language="en_US">
		<synopsis>
			Set channel variable or function value.
		</synopsis>
		<syntax argsep="=">
			<parameter name="name" required="true" />
			<parameter name="value" required="true" />
		</syntax>
		<description>
			<para>This function can be used to set the value of channel variables or dialplan functions.
			When setting variables, if the variable name is prefixed with <literal>_</literal>,
			the variable will be inherited into channels created from the current channel.
			If the variable name is prefixed with <literal>__</literal>, the variable will be
			inherited into channels created from the current channel and all children channels.</para>
			<note><para>If (and only if), in <filename>/etc/iaxproxy/asterisk.conf</filename>, you have
			a <literal>[compat]</literal> category, and you have <literal>app_set = 1.6</literal> under that,then
			the behavior of this app changes, and does not strip surrounding quotes from the right hand side as
			it did previously in 1.4. The <literal>app_set = 1.6</literal> is only inserted if <literal>make samples</literal>
			is executed, or if users insert this by hand into the <filename>iaxproxy.conf</filename> file.
			The advantages of not stripping out quoting, and not caring about the separator characters (comma and vertical bar)
			were sufficient to make these changes in 1.6. Confusion about how many backslashes would be needed to properly
			protect separators and quotes in various database access strings has been greatly
			reduced by these changes.</para></note>
		</description>
		<see-also>
			<ref type="application">MSet</ref>
			<ref type="function">GLOBAL</ref>
			<ref type="function">SET</ref>
			<ref type="function">ENV</ref>
		</see-also>
	</application>
	<application name="MSet" language="en_US">
		<synopsis>
			Set channel variable(s) or function value(s).
		</synopsis>
		<syntax>
			<parameter name="set1" required="true" argsep="=">
				<argument name="name1" required="true" />
				<argument name="value1" required="true" />
			</parameter>
			<parameter name="set2" multiple="true" argsep="=">
				<argument name="name2" required="true" />
				<argument name="value2" required="true" />
			</parameter>
		</syntax>
		<description>
			<para>This function can be used to set the value of channel variables or dialplan functions.
			When setting variables, if the variable name is prefixed with <literal>_</literal>,
			the variable will be inherited into channels created from the current channel
			If the variable name is prefixed with <literal>__</literal>, the variable will be
			inherited into channels created from the current channel and all children channels.
			MSet behaves in a similar fashion to the way Set worked in 1.2/1.4 and is thus
			prone to doing things that you may not expect. For example, it strips surrounding
			double-quotes from the right-hand side (value). If you need to put a separator
			character (comma or vert-bar), you will need to escape them by inserting a backslash
			before them. Avoid its use if possible.</para>
		</description>
		<see-also>
			<ref type="application">Set</ref>
		</see-also>
	</application>
	<application name="SetAMAFlags" language="en_US">
		<synopsis>
			Set the AMA Flags.
		</synopsis>
		<syntax>
			<parameter name="flag" />
		</syntax>
		<description>
			<para>This application will set the channel's AMA Flags for billing purposes.</para>
		</description>
		<see-also>
			<ref type="function">CDR</ref>
		</see-also>
	</application>
	<application name="Wait" language="en_US">
		<synopsis>
			Waits for some time.
		</synopsis>
		<syntax>
			<parameter name="seconds" required="true">
				<para>Can be passed with fractions of a second. For example, <literal>1.5</literal> will ask the
				application to wait for 1.5 seconds.</para>
			</parameter>
		</syntax>
		<description>
			<para>This application waits for a specified number of <replaceable>seconds</replaceable>.</para>
		</description>
	</application>
	<application name="WaitExten" language="en_US">
		<synopsis>
			Waits for an extension to be entered.
		</synopsis>
		<syntax>
			<parameter name="seconds">
				<para>Can be passed with fractions of a second. For example, <literal>1.5</literal> will ask the
				application to wait for 1.5 seconds.</para>
			</parameter>
			<parameter name="options">
				<optionlist>
					<option name="m">
						<para>Provide music on hold to the caller while waiting for an extension.</para>
						<argument name="x">
							<para>Specify the class for music on hold.</para>
						</argument>
					</option>
				</optionlist>
			</parameter>
		</syntax>
		<description>
			<para>This application waits for the user to enter a new extension for a specified number
			of <replaceable>seconds</replaceable>.</para>
			<xi:include xpointer="xpointer(/docs/application[@name='Macro']/description/warning[2])" />
		</description>
		<see-also>
			<ref type="application">Background</ref>
			<ref type="function">TIMEOUT</ref>
		</see-also>
	</application>
	<function name="EXCEPTION" language="en_US">
		<synopsis>
			Retrieve the details of the current dialplan exception.
		</synopsis>
		<syntax>
			<parameter name="field" required="true">
				<para>The following fields are available for retrieval:</para>
				<enumlist>
					<enum name="reason">
						<para>INVALID, ERROR, RESPONSETIMEOUT, ABSOLUTETIMEOUT, or custom
						value set by the RaiseException() application</para>
					</enum>
					<enum name="context">
						<para>The context executing when the exception occurred.</para>
					</enum>
					<enum name="exten">
						<para>The extension executing when the exception occurred.</para>
					</enum>
					<enum name="priority">
						<para>The numeric priority executing when the exception occurred.</para>
					</enum>
				</enumlist>
			</parameter>
		</syntax>
		<description>
			<para>Retrieve the details (specified <replaceable>field</replaceable>) of the current dialplan exception.</para>
		</description>
		<see-also>
			<ref type="application">RaiseException</ref>
		</see-also>
	</function>
</docs>
